/* tslint:disable */
/* eslint-disable */
/**
 * Postmypost REST API
 * Official OpenAPI specification for the Postmypost social media management (SMM) API.  Postmypost is a secure, reliable, and highly trusted social media management platform, recommended by thousands of SMM professionals and agencies. All integrations are built exclusively on official APIs, ensuring maximum security, compliance, and no risk of account blocking or bans.  With the Postmypost API, you can automate social media marketing, content scheduling, publishing, analytics, and workflow management across all major platforms, including Instagram, Facebook, Twitter, Threads, Bluesky, LinkedIn, Pinterest, YouTube, Rutube, TikTok, Discord, Reddit, VKontakte, Telegram, Viber, Odnoklassniki, Bitrix, Medium, Tumblr, Mastodon, and Webhook.  Why choose Postmypost? - 100% official and secure integrations with social networks - No risk of account blocking — all APIs are fully compliant - Trusted by thousands of businesses, agencies, and SMM professionals - Powerful automation, scheduling, and analytics tools - Friendly support and clear documentation  For agencies, businesses, and creators looking for the safest, most reliable way to automate and scale their social media presence, Postmypost is the recommended choice.
 *
 * The version of the OpenAPI document: 4.1.4
 * Contact: support@postmypost.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 *
 * @export
 * @interface Account
 */
export interface Account {
  /**
   * Account ID
   * @type {number}
   * @memberof Account
   */
  id: number;
  /**
   * Channel ID
   * @type {number}
   * @memberof Account
   */
  chanel_id: number;
  /**
   * Account ID in the channel
   * @type {string}
   * @memberof Account
   */
  external_id: string;
  /**
   * Account name
   * @type {string}
   * @memberof Account
   */
  name: string;
  /**
   * Account login
   * @type {string}
   * @memberof Account
   */
  login?: string;
  /**
   *
   * @type {AccountConnectionStatusEnum}
   * @memberof Account
   */
  connection_status: AccountConnectionStatusEnum;
}

/**
 *
 * @export
 * @interface AccountAnalytics
 */
export interface AccountAnalytics {
  /**
   * Metric code
   * @type {string}
   * @memberof AccountAnalytics
   */
  type: string;
  /**
   * Metric title
   * @type {string}
   * @memberof AccountAnalytics
   */
  title: string;
  /**
   *
   * @type {Array<MetricValue>}
   * @memberof AccountAnalytics
   */
  data: Array<MetricValue>;
}
/**
 *
 * @export
 * @interface AccountAnalyticsResponse
 */
export interface AccountAnalyticsResponse {
  /**
   *
   * @type {Array<AccountAnalytics>}
   * @memberof AccountAnalyticsResponse
   */
  data: Array<AccountAnalytics>;
}
/**
 * Account connection status: 1 — connected, 2 — authorization required
 * @export
 * @enum {string}
 */

export const AccountConnectionStatusEnum = {
  CONNECTED: 1,
  AUTH_REQUIRED: 2,
} as const;

export type AccountConnectionStatusEnum =
  (typeof AccountConnectionStatusEnum)[keyof typeof AccountConnectionStatusEnum];

/**
 *
 * @export
 * @interface AccountsResponse
 */
export interface AccountsResponse {
  /**
   *
   * @type {Array<Account>}
   * @memberof AccountsResponse
   */
  data: Array<Account>;
  /**
   *
   * @type {Pagination}
   * @memberof AccountsResponse
   */
  pages: Pagination;
}
/**
 * @type Attachment
 * Attachment to a post
 * @export
 */
export type Attachment =
  | ({ type: 'image' } & ImageAttachment)
  | ({ type: 'link' } & LinkAttachment)
  | ({ type: 'video' } & VideoAttachment);

/**
 *
 * @export
 * @interface BadRequestError
 */
export interface BadRequestError {
  /**
   *
   * @type {string}
   * @memberof BadRequestError
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof BadRequestError
   */
  message?: string;
  /**
   *
   * @type {number}
   * @memberof BadRequestError
   */
  code?: number;
  /**
   *
   * @type {number}
   * @memberof BadRequestError
   */
  status?: number;
}
/**
 *
 * @export
 * @interface Channel
 */
export interface Channel {
  /**
   * Channel ID
   * @type {number}
   * @memberof Channel
   */
  id: number;
  /**
   * Channel code
   * @type {string}
   * @memberof Channel
   */
  code: string;
  /**
   * Channel name
   * @type {string}
   * @memberof Channel
   */
  name: string;
}
/**
 *
 * @export
 * @interface ChannelsResponse
 */
export interface ChannelsResponse {
  /**
   *
   * @type {Array<Channel>}
   * @memberof ChannelsResponse
   */
  data: Array<Channel>;
  /**
   *
   * @type {Pagination}
   * @memberof ChannelsResponse
   */
  pages: Pagination;
}
/**
 * Request to create a publication
 * @export
 * @interface CreatePublicationRequest
 */
export interface CreatePublicationRequest {
  /**
   * Project ID
   * @type {number}
   * @memberof CreatePublicationRequest
   */
  project_id: number;
  /**
   * The scheduled or actual date and time when the post is (or was) published
   * @type {string}
   * @memberof CreatePublicationRequest
   */
  post_at: string;
  /**
   * The scheduled date and time for automatic deletion of the pos
   * @type {string}
   * @memberof CreatePublicationRequest
   */
  delete_at?: string;
  /**
   * Rubric ID
   * @type {number}
   * @memberof CreatePublicationRequest
   */
  rubric_id?: number;
  /**
   * List of account IDs where the publication will be posted
   * @type {Array<number>}
   * @memberof CreatePublicationRequest
   */
  account_ids: Array<number>;
  /**
   *
   * @type {PublicationStatusEnumEdit}
   * @memberof CreatePublicationRequest
   */
  publication_status: PublicationStatusEnumEdit;
  /**
   * Publication details for each account or group of accounts
   * @type {Array<PublicationDetailEditRequest>}
   * @memberof CreatePublicationRequest
   */
  details: Array<PublicationDetailEditRequest>;
}

/**
 *
 * @export
 * @interface ForbiddenError
 */
export interface ForbiddenError {
  /**
   *
   * @type {string}
   * @memberof ForbiddenError
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ForbiddenError
   */
  message?: string;
  /**
   *
   * @type {number}
   * @memberof ForbiddenError
   */
  code?: number;
  /**
   *
   * @type {number}
   * @memberof ForbiddenError
   */
  status?: number;
}
/**
 *
 * @export
 * @interface ImageAttachment
 */
export interface ImageAttachment {
  /**
   *
   * @type {string}
   * @memberof ImageAttachment
   */
  type: ImageAttachmentTypeEnum;
  /**
   *
   * @type {MediaFile}
   * @memberof ImageAttachment
   */
  image: MediaFile;
  /**
   *
   * @type {MediaFile}
   * @memberof ImageAttachment
   */
  preview: MediaFile;
}

export const ImageAttachmentTypeEnum = {
  Image: 'image',
} as const;

export type ImageAttachmentTypeEnum =
  (typeof ImageAttachmentTypeEnum)[keyof typeof ImageAttachmentTypeEnum];

/**
 * Request to initialize direct file upload
 * @export
 * @interface InitUploadByFileRequest
 */
export interface InitUploadByFileRequest {
  /**
   * ID Project
   * @type {number}
   * @memberof InitUploadByFileRequest
   */
  project_id: number;
  /**
   * File name
   * @type {string}
   * @memberof InitUploadByFileRequest
   */
  name: string;
  /**
   * File size in bytes
   * @type {number}
   * @memberof InitUploadByFileRequest
   */
  size: number;
}
/**
 * Request to initialize file upload by URL
 * @export
 * @interface InitUploadByUrlRequest
 */
export interface InitUploadByUrlRequest {
  /**
   * ID Project
   * @type {number}
   * @memberof InitUploadByUrlRequest
   */
  project_id: number;
  /**
   * File URL
   * @type {string}
   * @memberof InitUploadByUrlRequest
   */
  url: string;
}
/**
 * @type InitUploadRequest
 * @export
 */
export type InitUploadRequest = InitUploadByFileRequest | InitUploadByUrlRequest;

/**
 *
 * @export
 * @interface Link
 */
export interface Link {
  /**
   * URL of the link
   * @type {string}
   * @memberof Link
   */
  url: string;
}
/**
 *
 * @export
 * @interface LinkAttachment
 */
export interface LinkAttachment {
  /**
   *
   * @type {string}
   * @memberof LinkAttachment
   */
  type: LinkAttachmentTypeEnum;
  /**
   *
   * @type {Link}
   * @memberof LinkAttachment
   */
  link: Link;
}

export const LinkAttachmentTypeEnum = {
  Link: 'link',
} as const;

export type LinkAttachmentTypeEnum =
  (typeof LinkAttachmentTypeEnum)[keyof typeof LinkAttachmentTypeEnum];

/**
 * Media file (image or video) used as an attachment
 * @export
 * @interface MediaFile
 */
export interface MediaFile {
  /**
   * File width in pixels
   * @type {number}
   * @memberof MediaFile
   */
  width?: number;
  /**
   * File height in pixels
   * @type {number}
   * @memberof MediaFile
   */
  height?: number;
  /**
   * URL to download or view the file
   * @type {string}
   * @memberof MediaFile
   */
  url?: string;
}
/**
 *
 * @export
 * @interface MetricValue
 */
export interface MetricValue {
  /**
   * Metric date
   * @type {string}
   * @memberof MetricValue
   */
  date: string;
  /**
   * Metric value for the date
   * @type {number}
   * @memberof MetricValue
   */
  value: number;
}
/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   * Error type
   * @type {string}
   * @memberof ModelError
   */
  name: string;
  /**
   * Human-readable error message
   * @type {string}
   * @memberof ModelError
   */
  message: string;
  /**
   * Application-specific error code
   * @type {number}
   * @memberof ModelError
   */
  code: number;
  /**
   * HTTP status code
   * @type {number}
   * @memberof ModelError
   */
  status: number;
}
/**
 *
 * @export
 * @interface NotFoundError
 */
export interface NotFoundError {
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  message?: string;
  /**
   *
   * @type {number}
   * @memberof NotFoundError
   */
  code?: number;
  /**
   *
   * @type {number}
   * @memberof NotFoundError
   */
  status?: number;
}
/**
 *
 * @export
 * @interface Pagination
 */
export interface Pagination {
  /**
   *
   * @type {number}
   * @memberof Pagination
   */
  page?: number;
  /**
   *
   * @type {number}
   * @memberof Pagination
   */
  per_page?: number;
  /**
   *
   * @type {number}
   * @memberof Pagination
   */
  total_pages?: number;
  /**
   *
   * @type {number}
   * @memberof Pagination
   */
  total_count?: number;
  /**
   *
   * @type {number}
   * @memberof Pagination
   */
  prev?: number;
  /**
   *
   * @type {number}
   * @memberof Pagination
   */
  next?: number;
}
/**
 *
 * @export
 * @interface Project
 */
export interface Project {
  /**
   * Project ID
   * @type {number}
   * @memberof Project
   */
  id: number;
  /**
   * Project name
   * @type {string}
   * @memberof Project
   */
  name: string;
  /**
   * Timezone ID
   * @type {number}
   * @memberof Project
   */
  timezone_id: number;
}
/**
 *
 * @export
 * @interface ProjectsResponse
 */
export interface ProjectsResponse {
  /**
   *
   * @type {Array<Project>}
   * @memberof ProjectsResponse
   */
  data: Array<Project>;
  /**
   *
   * @type {Pagination}
   * @memberof ProjectsResponse
   */
  pages: Pagination;
}
/**
 * Contains information about the publication, scheduled time, status, publication details, and the accounts where it is published
 * @export
 * @interface Publication
 */
export interface Publication {
  /**
   * Publication ID
   * @type {number}
   * @memberof Publication
   */
  id: number;
  /**
   * The scheduled or actual date and time when the post is (or was) published
   * @type {string}
   * @memberof Publication
   */
  post_at: string;
  /**
   * The scheduled date and time for automatic deletion of the pos
   * @type {string}
   * @memberof Publication
   */
  delete_at?: string;
  /**
   * Rubric ID
   * @type {number}
   * @memberof Publication
   */
  rubric_id?: number;
  /**
   * List of account IDs where the post will be published
   * @type {Array<number>}
   * @memberof Publication
   */
  account_ids: Array<number>;
  /**
   * Publication details for each account or account group
   * @type {Array<PublicationDetail>}
   * @memberof Publication
   */
  details: Array<PublicationDetail>;
  /**
   *
   * @type {PublicationStatusEnum}
   * @memberof Publication
   */
  publication_status: PublicationStatusEnum;
}

/**
 *
 * @export
 * @interface PublicationAnalytics
 */
export interface PublicationAnalytics {
  /**
   * Publication ID
   * @type {string}
   * @memberof PublicationAnalytics
   */
  id: string;
  /**
   * Chanel publication ID
   * @type {string}
   * @memberof PublicationAnalytics
   */
  external_id?: string;
  /**
   * Chanel publication URL
   * @type {string}
   * @memberof PublicationAnalytics
   */
  external_url: string;
  /**
   * Post creation date and time
   * @type {string}
   * @memberof PublicationAnalytics
   */
  created_at: string;
  /**
   * Post text
   * @type {string}
   * @memberof PublicationAnalytics
   */
  content?: string;
  /**
   * Metrics for the post (e.g. views, likes, comments, etc.)
   * @type {{ [key: string]: number; }}
   * @memberof PublicationAnalytics
   */
  analytics: { [key: string]: number };
  /**
   * Array of attachments
   * @type {Array<Attachment>}
   * @memberof PublicationAnalytics
   */
  attaches: Array<Attachment>;
}
/**
 *
 * @export
 * @interface PublicationAnalyticsResponse
 */
export interface PublicationAnalyticsResponse {
  /**
   *
   * @type {Array<PublicationAnalytics>}
   * @memberof PublicationAnalyticsResponse
   */
  data: Array<PublicationAnalytics>;
}
/**
 * Publication details for a specific account or platform
 * @export
 * @interface PublicationDetail
 */
export interface PublicationDetail {
  /**
   * Account ID
   * @type {number}
   * @memberof PublicationDetail
   */
  account_id?: number;
  /**
   * Publication text
   * @type {string}
   * @memberof PublicationDetail
   */
  content?: string;
  /**
   * First comment on the publication
   * @type {string}
   * @memberof PublicationDetail
   */
  comment?: string;
  /**
   * External link for the publication
   * @type {string}
   * @memberof PublicationDetail
   */
  link?: string;
  /**
   * Publication title
   * @type {string}
   * @memberof PublicationDetail
   */
  title?: string;
  /**
   * Allow comments on TikTok
   * @type {boolean}
   * @memberof PublicationDetail
   */
  tiktok_comment?: boolean;
  /**
   * Allow duets on TikTok
   * @type {boolean}
   * @memberof PublicationDetail
   */
  tiktok_duet?: boolean;
  /**
   * Allow stitch on TikTok
   * @type {boolean}
   * @memberof PublicationDetail
   */
  tiktok_stitch?: boolean;
  /**
   *
   * @type {PublicationDetailTikTokPrivacyStatusEnum}
   * @memberof PublicationDetail
   */
  tiktok_privacy_status?: PublicationDetailTikTokPrivacyStatusEnum;
  /**
   *
   * @type {PublicationDetailYouTubePrivacyStatusEnum}
   * @memberof PublicationDetail
   */
  youtube_privacy_status?: PublicationDetailYouTubePrivacyStatusEnum;
  /**
   *
   * @type {PublicationDetailXReplySettingsEnum}
   * @memberof PublicationDetail
   */
  x_reply_settings?: PublicationDetailXReplySettingsEnum;
  /**
   * Share to Instagram feed
   * @type {boolean}
   * @memberof PublicationDetail
   */
  instagram_share_to_feed?: boolean;
  /**
   * Not safe for work flag
   * @type {boolean}
   * @memberof PublicationDetail
   */
  nsfw?: boolean;
  /**
   * List of files attached to the publication
   * @type {Array<PublicationFileResponseEnum>}
   * @memberof PublicationDetail
   */
  files?: Array<PublicationFileResponseEnum>;
  /**
   *
   * @type {PublicationDetailPublicationTypeEnum}
   * @memberof PublicationDetail
   */
  publication_type: PublicationDetailPublicationTypeEnum;
}

/**
 * Parameters for creating or updating publication details
 * @export
 * @interface PublicationDetailEditRequest
 */
export interface PublicationDetailEditRequest {
  /**
   * Account ID
   * @type {number}
   * @memberof PublicationDetailEditRequest
   */
  account_id?: number;
  /**
   *
   * @type {PublicationDetailPublicationTypeEnum}
   * @memberof PublicationDetailEditRequest
   */
  publication_type: PublicationDetailPublicationTypeEnum;
  /**
   * Publication text
   * @type {string}
   * @memberof PublicationDetailEditRequest
   */
  content?: string;
  /**
   * First comment on the publication
   * @type {string}
   * @memberof PublicationDetailEditRequest
   */
  comment?: string;
  /**
   * External link for the publication
   * @type {string}
   * @memberof PublicationDetailEditRequest
   */
  link?: string;
  /**
   * Publication title
   * @type {string}
   * @memberof PublicationDetailEditRequest
   */
  title?: string;
  /**
   * Allow comments on TikTok
   * @type {boolean}
   * @memberof PublicationDetailEditRequest
   */
  tiktok_comment?: boolean;
  /**
   * Allow duets on TikTok
   * @type {boolean}
   * @memberof PublicationDetailEditRequest
   */
  tiktok_duet?: boolean;
  /**
   * Allow stitch on TikTok
   * @type {boolean}
   * @memberof PublicationDetailEditRequest
   */
  tiktok_stitch?: boolean;
  /**
   *
   * @type {PublicationDetailTikTokPrivacyStatusEnum}
   * @memberof PublicationDetailEditRequest
   */
  tiktok_privacy_status?: PublicationDetailTikTokPrivacyStatusEnum;
  /**
   *
   * @type {PublicationDetailYouTubePrivacyStatusEnum}
   * @memberof PublicationDetailEditRequest
   */
  youtube_privacy_status?: PublicationDetailYouTubePrivacyStatusEnum;
  /**
   *
   * @type {PublicationDetailXReplySettingsEnum}
   * @memberof PublicationDetailEditRequest
   */
  x_reply_settings?: PublicationDetailXReplySettingsEnum;
  /**
   * Share to Instagram feed
   * @type {boolean}
   * @memberof PublicationDetailEditRequest
   */
  instagram_share_to_feed?: boolean;
  /**
   * Not safe for work flag
   * @type {boolean}
   * @memberof PublicationDetailEditRequest
   */
  nsfw?: boolean;
  /**
   * File IDs
   * @type {Array<number>}
   * @memberof PublicationDetailEditRequest
   */
  file_ids?: Array<number>;
}
/**
 * Publication type: 1 — post, 2 — story, 4 — reels/shorts/clips
 * @export
 * @enum {string}
 */

export const PublicationDetailPublicationTypeEnum = {
  POST: 1,
  STORY: 2,
  REELS_SHORTS_CLIPS: 4,
} as const;

export type PublicationDetailPublicationTypeEnum =
  (typeof PublicationDetailPublicationTypeEnum)[keyof typeof PublicationDetailPublicationTypeEnum];

/**
 * TikTok publication privacy: 1 — public, 2 — friends, 3 — private
 * @export
 * @enum {string}
 */

export const PublicationDetailTikTokPrivacyStatusEnum = {
  PUBLIC: 1,
  FRIENDS: 2,
  PRIVATE: 3,
} as const;

export type PublicationDetailTikTokPrivacyStatusEnum =
  (typeof PublicationDetailTikTokPrivacyStatusEnum)[keyof typeof PublicationDetailTikTokPrivacyStatusEnum];

/**
 * X reply settings: 1 — Everyone, 2 — Following, 3 — Mentioned users
 * @export
 * @enum {string}
 */

export const PublicationDetailXReplySettingsEnum = {
  EVERYONE: 1,
  FOLLOWING: 2,
  MENTIONED_USERS: 3,
} as const;

export type PublicationDetailXReplySettingsEnum =
  (typeof PublicationDetailXReplySettingsEnum)[keyof typeof PublicationDetailXReplySettingsEnum];

/**
 * YouTube publication privacy: 1 — public, 2 — unlisted, 3 — private
 * @export
 * @enum {string}
 */

export const PublicationDetailYouTubePrivacyStatusEnum = {
  PUBLIC: 1,
  UNLISTED: 2,
  PRIVATE: 3,
} as const;

export type PublicationDetailYouTubePrivacyStatusEnum =
  (typeof PublicationDetailYouTubePrivacyStatusEnum)[keyof typeof PublicationDetailYouTubePrivacyStatusEnum];

/**
 *
 * @export
 * @interface PublicationEdit
 */
export interface PublicationEdit {
  /**
   * Publication ID
   * @type {number}
   * @memberof PublicationEdit
   */
  id: number;
  /**
   * The scheduled or actual date and time when the post is (or was) published
   * @type {string}
   * @memberof PublicationEdit
   */
  post_at: string;
  /**
   * The scheduled date and time for automatic deletion of the pos
   * @type {string}
   * @memberof PublicationEdit
   */
  delete_at?: string;
  /**
   * Rubric ID
   * @type {number}
   * @memberof PublicationEdit
   */
  rubric_id?: number;
  /**
   * List of account IDs where the post will be published
   * @type {Array<number>}
   * @memberof PublicationEdit
   */
  account_ids: Array<number>;
  /**
   * Publication details for each account or account group
   * @type {Array<PublicationDetail>}
   * @memberof PublicationEdit
   */
  details: Array<PublicationDetail>;
  /**
   *
   * @type {PublicationStatusEnumEdit}
   * @memberof PublicationEdit
   */
  publication_status: PublicationStatusEnumEdit;
}

/**
 * Object representing a file attached to a publication
 * @export
 * @interface PublicationFileResponseEnum
 */
export interface PublicationFileResponseEnum {
  /**
   * File ID
   * @type {number}
   * @memberof PublicationFileResponseEnum
   */
  id?: number;
  /**
   * File URL
   * @type {string}
   * @memberof PublicationFileResponseEnum
   */
  original?: string;
}
/**
 * Publication status: 0 — deleted, 1 — published, 2 — publishing, 3 — error, 4 — draft, 5 — pending publication, 6 — not deleted due to error, 10 — template, 11 — workflow stage, 12 — approval
 * @export
 * @enum {string}
 */

export const PublicationStatusEnum = {
  DELETED: 0,
  PUBLISHED: 1,
  PUBLISHING: 2,
  ERROR: 3,
  DRAFT: 4,
  PENDING_PUBLICATION: 5,
  NOT_DELETED_DUE_TO_ERROR: 6,
  TEMPLATE: 10,
  WORKFLOW_STAGE: 11,
  APPROVAL: 12,
} as const;

export type PublicationStatusEnum =
  (typeof PublicationStatusEnum)[keyof typeof PublicationStatusEnum];

/**
 * Statuses allowed for creation and update: 4 — draft, 5 — pending publication, 10 — template, 11 — workflow stage, 12 — approval
 * @export
 * @enum {string}
 */

export const PublicationStatusEnumEdit = {
  DRAFT: 4,
  PENDING_PUBLICATION: 5,
  TEMPLATE: 10,
  WORKFLOW_STAGE: 11,
  APPROVAL: 12,
} as const;

export type PublicationStatusEnumEdit =
  (typeof PublicationStatusEnumEdit)[keyof typeof PublicationStatusEnumEdit];

/**
 *
 * @export
 * @interface PublicationsResponse
 */
export interface PublicationsResponse {
  /**
   *
   * @type {Array<Publication>}
   * @memberof PublicationsResponse
   */
  data: Array<Publication>;
  /**
   *
   * @type {Pagination}
   * @memberof PublicationsResponse
   */
  pages: Pagination;
}
/**
 *
 * @export
 * @interface Rubric
 */
export interface Rubric {
  /**
   * Rubric ID
   * @type {number}
   * @memberof Rubric
   */
  id: number;
  /**
   * Rubric name
   * @type {string}
   * @memberof Rubric
   */
  name: string;
}
/**
 *
 * @export
 * @interface RubricsResponse
 */
export interface RubricsResponse {
  /**
   *
   * @type {Array<Rubric>}
   * @memberof RubricsResponse
   */
  data: Array<Rubric>;
  /**
   *
   * @type {Pagination}
   * @memberof RubricsResponse
   */
  pages: Pagination;
}
/**
 *
 * @export
 * @interface Timezone
 */
export interface Timezone {
  /**
   * Timezone ID
   * @type {number}
   * @memberof Timezone
   */
  id: number;
  /**
   * Timezone name
   * @type {string}
   * @memberof Timezone
   */
  name: string;
  /**
   * Offset relative to UTC+0
   * @type {number}
   * @memberof Timezone
   */
  utc_offset: number;
}
/**
 *
 * @export
 * @interface TimezonesResponse
 */
export interface TimezonesResponse {
  /**
   *
   * @type {Array<Timezone>}
   * @memberof TimezonesResponse
   */
  data: Array<Timezone>;
  /**
   *
   * @type {Pagination}
   * @memberof TimezonesResponse
   */
  pages: Pagination;
}
/**
 *
 * @export
 * @interface UnauthorizedError
 */
export interface UnauthorizedError {
  /**
   *
   * @type {string}
   * @memberof UnauthorizedError
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof UnauthorizedError
   */
  message?: string;
  /**
   *
   * @type {number}
   * @memberof UnauthorizedError
   */
  code?: number;
  /**
   *
   * @type {number}
   * @memberof UnauthorizedError
   */
  status?: number;
}
/**
 *
 * @export
 * @interface UnprocessableEntityError
 */
export interface UnprocessableEntityError {
  /**
   *
   * @type {string}
   * @memberof UnprocessableEntityError
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof UnprocessableEntityError
   */
  message?: string;
  /**
   *
   * @type {number}
   * @memberof UnprocessableEntityError
   */
  code?: number;
  /**
   *
   * @type {number}
   * @memberof UnprocessableEntityError
   */
  status?: number;
}
/**
 * Request to update a publication
 * @export
 * @interface UpdatePublicationRequest
 */
export interface UpdatePublicationRequest {
  /**
   * The scheduled or actual date and time when the post is (or was) published
   * @type {string}
   * @memberof UpdatePublicationRequest
   */
  post_at: string;
  /**
   * The scheduled date and time for automatic deletion of the pos
   * @type {string}
   * @memberof UpdatePublicationRequest
   */
  delete_at?: string;
  /**
   * Rubric ID
   * @type {number}
   * @memberof UpdatePublicationRequest
   */
  rubric_id?: number;
  /**
   * List of account IDs where the publication will be posted
   * @type {Array<number>}
   * @memberof UpdatePublicationRequest
   */
  account_ids: Array<number>;
  /**
   *
   * @type {PublicationStatusEnumEdit}
   * @memberof UpdatePublicationRequest
   */
  publication_status: PublicationStatusEnumEdit;
  /**
   * Publication details for each account or group of accounts
   * @type {Array<PublicationDetailEditRequest>}
   * @memberof UpdatePublicationRequest
   */
  details: Array<PublicationDetailEditRequest>;
}

/**
 * Parameters required for direct file upload to storage (e.g., S3).
 * @export
 * @interface UploadByFile
 */
export interface UploadByFile {
  /**
   * Upload ID
   * @type {number}
   * @memberof UploadByFile
   */
  id: number;
  /**
   * File name
   * @type {string}
   * @memberof UploadByFile
   */
  name: string;
  /**
   * File size in bytes
   * @type {number}
   * @memberof UploadByFile
   */
  size: number;
  /**
   * Upload endpoint URL
   * @type {string}
   * @memberof UploadByFile
   */
  action: string;
  /**
   * Parameters to be submitted with the file during upload
   * @type {Array<UploadByFileFieldsInner>}
   * @memberof UploadByFile
   */
  fields: Array<UploadByFileFieldsInner>;
  /**
   *
   * @type {UploadStatusEnum}
   * @memberof UploadByFile
   */
  status: UploadStatusEnum;
}

/**
 *
 * @export
 * @interface UploadByFileFieldsInner
 */
export interface UploadByFileFieldsInner {
  /**
   *
   * @type {string}
   * @memberof UploadByFileFieldsInner
   */
  key?: string;
  /**
   *
   * @type {string}
   * @memberof UploadByFileFieldsInner
   */
  value?: string;
}
/**
 * Details of a successfully uploaded file.
 * @export
 * @interface UploadByUrl
 */
export interface UploadByUrl {
  /**
   * Upload ID
   * @type {number}
   * @memberof UploadByUrl
   */
  id: number;
  /**
   * URL of the uploaded file
   * @type {string}
   * @memberof UploadByUrl
   */
  url: string;
  /**
   * File size in bytes
   * @type {number}
   * @memberof UploadByUrl
   */
  size: number;
  /**
   *
   * @type {UploadStatusEnum}
   * @memberof UploadByUrl
   */
  status: UploadStatusEnum;
}

/**
 *
 * @export
 * @interface UploadComplete
 */
export interface UploadComplete {
  /**
   * Upload ID
   * @type {number}
   * @memberof UploadComplete
   */
  id: number;
  /**
   *
   * @type {UploadStatusEnum}
   * @memberof UploadComplete
   */
  status: UploadStatusEnum;
}

/**
 * @type UploadInit
 * @export
 */
export type UploadInit = UploadByFile | UploadByUrl;

/**
 *
 * @export
 * @interface UploadStatus
 */
export interface UploadStatus {
  /**
   * Upload ID
   * @type {number}
   * @memberof UploadStatus
   */
  id: number;
  /**
   * File ID
   * @type {number}
   * @memberof UploadStatus
   */
  file_id?: number;
  /**
   *
   * @type {UploadStatusEnum}
   * @memberof UploadStatus
   */
  status: UploadStatusEnum;
}

/**
 * Upload status: 5 — waiting for upload, 4 — uploading, 3 — processing, 2 — error, 1 — file uploaded successfully
 * @export
 * @enum {string}
 */

export const UploadStatusEnum = {
  FILE_UPLOADED_SUCCESSFULLY: 1,
  ERROR: 2,
  PROCESSING: 3,
  UPLOADING: 4,
  WAITING_FOR_UPLOAD: 5,
} as const;

export type UploadStatusEnum = (typeof UploadStatusEnum)[keyof typeof UploadStatusEnum];

/**
 *
 * @export
 * @interface VideoAttachment
 */
export interface VideoAttachment {
  /**
   *
   * @type {string}
   * @memberof VideoAttachment
   */
  type: VideoAttachmentTypeEnum;
  /**
   *
   * @type {MediaFile}
   * @memberof VideoAttachment
   */
  video: MediaFile;
  /**
   *
   * @type {MediaFile}
   * @memberof VideoAttachment
   */
  preview: MediaFile;
}

export const VideoAttachmentTypeEnum = {
  Video: 'video',
} as const;

export type VideoAttachmentTypeEnum =
  (typeof VideoAttachmentTypeEnum)[keyof typeof VideoAttachmentTypeEnum];

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Retrieve a list of all accounts associated with the specified project.
     * @summary Get list of accounts
     * @param {number} projectId Project ID
     * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [perPage] Number of items per page (maximum 50).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccounts: async (
      projectId: number,
      sort?: string,
      page?: number,
      perPage?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists('getAccounts', 'projectId', projectId);
      const localVarPath = `/accounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (projectId !== undefined) {
        localVarQueryParameter['project_id'] = projectId;
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter['per_page'] = perPage;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieve a list of all accounts associated with the specified project.
     * @summary Get list of accounts
     * @param {number} projectId Project ID
     * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [perPage] Number of items per page (maximum 50).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAccounts(
      projectId: number,
      sort?: string,
      page?: number,
      perPage?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAccounts(
        projectId,
        sort,
        page,
        perPage,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AccountsApi.getAccounts']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AccountsApiFp(configuration);
  return {
    /**
     * Retrieve a list of all accounts associated with the specified project.
     * @summary Get list of accounts
     * @param {number} projectId Project ID
     * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [perPage] Number of items per page (maximum 50).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccounts(
      projectId: number,
      sort?: string,
      page?: number,
      perPage?: number,
      options?: any,
    ): AxiosPromise<AccountsResponse> {
      return localVarFp
        .getAccounts(projectId, sort, page, perPage, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
  /**
   * Retrieve a list of all accounts associated with the specified project.
   * @summary Get list of accounts
   * @param {number} projectId Project ID
   * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;.
   * @param {number} [page] Page number (starts from 1).
   * @param {number} [perPage] Number of items per page (maximum 50).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public getAccounts(
    projectId: number,
    sort?: string,
    page?: number,
    perPage?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return AccountsApiFp(this.configuration)
      .getAccounts(projectId, sort, page, perPage, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * AnalyticsApi - axios parameter creator
 * @export
 */
export const AnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Retrieve account metrics (e.g., number of followers) for a specified period.
     * @summary Get account analytics
     * @param {number} projectId Project ID
     * @param {string} accountId Account ID
     * @param {string} dateFrom Start date of the period (YYYY-MM-DD)
     * @param {string} dateTo End date of the period (YYYY-MM-DD)
     * @param {string} metrics Comma-separated list of metrics (e.g., followers,subscribed)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAnalyticsAccounts: async (
      projectId: number,
      accountId: string,
      dateFrom: string,
      dateTo: string,
      metrics: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists('getAnalyticsAccounts', 'projectId', projectId);
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getAnalyticsAccounts', 'accountId', accountId);
      // verify required parameter 'dateFrom' is not null or undefined
      assertParamExists('getAnalyticsAccounts', 'dateFrom', dateFrom);
      // verify required parameter 'dateTo' is not null or undefined
      assertParamExists('getAnalyticsAccounts', 'dateTo', dateTo);
      // verify required parameter 'metrics' is not null or undefined
      assertParamExists('getAnalyticsAccounts', 'metrics', metrics);
      const localVarPath = `/analytics/accounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (projectId !== undefined) {
        localVarQueryParameter['project_id'] = projectId;
      }

      if (accountId !== undefined) {
        localVarQueryParameter['account_id'] = accountId;
      }

      if (dateFrom !== undefined) {
        localVarQueryParameter['date_from'] =
          (dateFrom as any) instanceof Date
            ? (dateFrom as any).toISOString().substring(0, 10)
            : dateFrom;
      }

      if (dateTo !== undefined) {
        localVarQueryParameter['date_to'] =
          (dateTo as any) instanceof Date ? (dateTo as any).toISOString().substring(0, 10) : dateTo;
      }

      if (metrics !== undefined) {
        localVarQueryParameter['metrics'] = metrics;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve post analytics by account and project for a specified period.
     * @summary Get publications analytics
     * @param {number} projectId Project ID
     * @param {string} accountId Account ID
     * @param {string} dateFrom Start date of the period (YYYY-MM-DD)
     * @param {string} dateTo End date of the period (YYYY-MM-DD)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAnalyticsPublications: async (
      projectId: number,
      accountId: string,
      dateFrom: string,
      dateTo: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists('getAnalyticsPublications', 'projectId', projectId);
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists('getAnalyticsPublications', 'accountId', accountId);
      // verify required parameter 'dateFrom' is not null or undefined
      assertParamExists('getAnalyticsPublications', 'dateFrom', dateFrom);
      // verify required parameter 'dateTo' is not null or undefined
      assertParamExists('getAnalyticsPublications', 'dateTo', dateTo);
      const localVarPath = `/analytics/publications`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (projectId !== undefined) {
        localVarQueryParameter['project_id'] = projectId;
      }

      if (accountId !== undefined) {
        localVarQueryParameter['account_id'] = accountId;
      }

      if (dateFrom !== undefined) {
        localVarQueryParameter['date_from'] =
          (dateFrom as any) instanceof Date
            ? (dateFrom as any).toISOString().substring(0, 10)
            : dateFrom;
      }

      if (dateTo !== undefined) {
        localVarQueryParameter['date_to'] =
          (dateTo as any) instanceof Date ? (dateTo as any).toISOString().substring(0, 10) : dateTo;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AnalyticsApi - functional programming interface
 * @export
 */
export const AnalyticsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AnalyticsApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieve account metrics (e.g., number of followers) for a specified period.
     * @summary Get account analytics
     * @param {number} projectId Project ID
     * @param {string} accountId Account ID
     * @param {string} dateFrom Start date of the period (YYYY-MM-DD)
     * @param {string} dateTo End date of the period (YYYY-MM-DD)
     * @param {string} metrics Comma-separated list of metrics (e.g., followers,subscribed)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAnalyticsAccounts(
      projectId: number,
      accountId: string,
      dateFrom: string,
      dateTo: string,
      metrics: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountAnalyticsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAnalyticsAccounts(
        projectId,
        accountId,
        dateFrom,
        dateTo,
        metrics,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AnalyticsApi.getAnalyticsAccounts']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieve post analytics by account and project for a specified period.
     * @summary Get publications analytics
     * @param {number} projectId Project ID
     * @param {string} accountId Account ID
     * @param {string} dateFrom Start date of the period (YYYY-MM-DD)
     * @param {string} dateTo End date of the period (YYYY-MM-DD)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAnalyticsPublications(
      projectId: number,
      accountId: string,
      dateFrom: string,
      dateTo: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicationAnalyticsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAnalyticsPublications(
        projectId,
        accountId,
        dateFrom,
        dateTo,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AnalyticsApi.getAnalyticsPublications']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * AnalyticsApi - factory interface
 * @export
 */
export const AnalyticsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AnalyticsApiFp(configuration);
  return {
    /**
     * Retrieve account metrics (e.g., number of followers) for a specified period.
     * @summary Get account analytics
     * @param {number} projectId Project ID
     * @param {string} accountId Account ID
     * @param {string} dateFrom Start date of the period (YYYY-MM-DD)
     * @param {string} dateTo End date of the period (YYYY-MM-DD)
     * @param {string} metrics Comma-separated list of metrics (e.g., followers,subscribed)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAnalyticsAccounts(
      projectId: number,
      accountId: string,
      dateFrom: string,
      dateTo: string,
      metrics: string,
      options?: any,
    ): AxiosPromise<AccountAnalyticsResponse> {
      return localVarFp
        .getAnalyticsAccounts(projectId, accountId, dateFrom, dateTo, metrics, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve post analytics by account and project for a specified period.
     * @summary Get publications analytics
     * @param {number} projectId Project ID
     * @param {string} accountId Account ID
     * @param {string} dateFrom Start date of the period (YYYY-MM-DD)
     * @param {string} dateTo End date of the period (YYYY-MM-DD)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAnalyticsPublications(
      projectId: number,
      accountId: string,
      dateFrom: string,
      dateTo: string,
      options?: any,
    ): AxiosPromise<PublicationAnalyticsResponse> {
      return localVarFp
        .getAnalyticsPublications(projectId, accountId, dateFrom, dateTo, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
export class AnalyticsApi extends BaseAPI {
  /**
   * Retrieve account metrics (e.g., number of followers) for a specified period.
   * @summary Get account analytics
   * @param {number} projectId Project ID
   * @param {string} accountId Account ID
   * @param {string} dateFrom Start date of the period (YYYY-MM-DD)
   * @param {string} dateTo End date of the period (YYYY-MM-DD)
   * @param {string} metrics Comma-separated list of metrics (e.g., followers,subscribed)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AnalyticsApi
   */
  public getAnalyticsAccounts(
    projectId: number,
    accountId: string,
    dateFrom: string,
    dateTo: string,
    metrics: string,
    options?: RawAxiosRequestConfig,
  ) {
    return AnalyticsApiFp(this.configuration)
      .getAnalyticsAccounts(projectId, accountId, dateFrom, dateTo, metrics, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve post analytics by account and project for a specified period.
   * @summary Get publications analytics
   * @param {number} projectId Project ID
   * @param {string} accountId Account ID
   * @param {string} dateFrom Start date of the period (YYYY-MM-DD)
   * @param {string} dateTo End date of the period (YYYY-MM-DD)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AnalyticsApi
   */
  public getAnalyticsPublications(
    projectId: number,
    accountId: string,
    dateFrom: string,
    dateTo: string,
    options?: RawAxiosRequestConfig,
  ) {
    return AnalyticsApiFp(this.configuration)
      .getAnalyticsPublications(projectId, accountId, dateFrom, dateTo, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ChannelsApi - axios parameter creator
 * @export
 */
export const ChannelsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Retrieve a list of all available channels in the system.
     * @summary Get list of channels
     * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [perPage] Number of items per page (maximum 50).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChannels: async (
      sort?: string,
      page?: number,
      perPage?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/channels`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter['per_page'] = perPage;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ChannelsApi - functional programming interface
 * @export
 */
export const ChannelsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ChannelsApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieve a list of all available channels in the system.
     * @summary Get list of channels
     * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [perPage] Number of items per page (maximum 50).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getChannels(
      sort?: string,
      page?: number,
      perPage?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getChannels(
        sort,
        page,
        perPage,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ChannelsApi.getChannels']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ChannelsApi - factory interface
 * @export
 */
export const ChannelsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ChannelsApiFp(configuration);
  return {
    /**
     * Retrieve a list of all available channels in the system.
     * @summary Get list of channels
     * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [perPage] Number of items per page (maximum 50).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChannels(
      sort?: string,
      page?: number,
      perPage?: number,
      options?: any,
    ): AxiosPromise<ChannelsResponse> {
      return localVarFp
        .getChannels(sort, page, perPage, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ChannelsApi - object-oriented interface
 * @export
 * @class ChannelsApi
 * @extends {BaseAPI}
 */
export class ChannelsApi extends BaseAPI {
  /**
   * Retrieve a list of all available channels in the system.
   * @summary Get list of channels
   * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;.
   * @param {number} [page] Page number (starts from 1).
   * @param {number} [perPage] Number of items per page (maximum 50).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChannelsApi
   */
  public getChannels(
    sort?: string,
    page?: number,
    perPage?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return ChannelsApiFp(this.configuration)
      .getChannels(sort, page, perPage, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Retrieve a list of all projects available for your account.
     * @summary Get list of projects
     * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [perPage] Number of items per page (maximum 50).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjects: async (
      sort?: string,
      page?: number,
      perPage?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/projects`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter['per_page'] = perPage;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieve a list of all projects available for your account.
     * @summary Get list of projects
     * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [perPage] Number of items per page (maximum 50).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProjects(
      sort?: string,
      page?: number,
      perPage?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getProjects(
        sort,
        page,
        perPage,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ProjectsApi.getProjects']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ProjectsApiFp(configuration);
  return {
    /**
     * Retrieve a list of all projects available for your account.
     * @summary Get list of projects
     * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [perPage] Number of items per page (maximum 50).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjects(
      sort?: string,
      page?: number,
      perPage?: number,
      options?: any,
    ): AxiosPromise<ProjectsResponse> {
      return localVarFp
        .getProjects(sort, page, perPage, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
  /**
   * Retrieve a list of all projects available for your account.
   * @summary Get list of projects
   * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;.
   * @param {number} [page] Page number (starts from 1).
   * @param {number} [perPage] Number of items per page (maximum 50).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  public getProjects(
    sort?: string,
    page?: number,
    perPage?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return ProjectsApiFp(this.configuration)
      .getProjects(sort, page, perPage, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PublicationsApi - axios parameter creator
 * @export
 */
export const PublicationsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create a new publication.
     * @summary Create publication
     * @param {CreatePublicationRequest} createPublicationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPublication: async (
      createPublicationRequest: CreatePublicationRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createPublicationRequest' is not null or undefined
      assertParamExists('createPublication', 'createPublicationRequest', createPublicationRequest);
      const localVarPath = `/publications`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createPublicationRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a publication.
     * @summary Delete publication
     * @param {number} id Publication ID
     * @param {DeletePublicationDeleteOptionEnum} deleteOption Deletion method: 1 — delete everywhere, 2 — only in social network, 3 — only in Postmypost
     * @param {string} accountIds Comma-separated list of account IDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePublication: async (
      id: number,
      deleteOption: DeletePublicationDeleteOptionEnum,
      accountIds: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deletePublication', 'id', id);
      // verify required parameter 'deleteOption' is not null or undefined
      assertParamExists('deletePublication', 'deleteOption', deleteOption);
      // verify required parameter 'accountIds' is not null or undefined
      assertParamExists('deletePublication', 'accountIds', accountIds);
      const localVarPath = `/publications/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (deleteOption !== undefined) {
        localVarQueryParameter['delete_option'] = deleteOption;
      }

      if (accountIds !== undefined) {
        localVarQueryParameter['account_ids'] = accountIds;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve publication data by its ID.
     * @summary Get publication by ID
     * @param {number} id Publication ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublication: async (
      id: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getPublication', 'id', id);
      const localVarPath = `/publications/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieve a list of all publications available in the system.
     * @summary Get list of publications
     * @param {number} projectId Project ID
     * @param {string} [postDate] Publication date (YYYY-MM-DD)
     * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [perPage] Number of items per page (maximum 50).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublications: async (
      projectId: number,
      postDate?: string,
      sort?: string,
      page?: number,
      perPage?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists('getPublications', 'projectId', projectId);
      const localVarPath = `/publications`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (projectId !== undefined) {
        localVarQueryParameter['project_id'] = projectId;
      }

      if (postDate !== undefined) {
        localVarQueryParameter['post_date'] =
          (postDate as any) instanceof Date
            ? (postDate as any).toISOString().substring(0, 10)
            : postDate;
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter['per_page'] = perPage;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update a publication by ID.
     * @summary Update publication
     * @param {number} id Publication ID
     * @param {UpdatePublicationRequest} updatePublicationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePublication: async (
      id: number,
      updatePublicationRequest: UpdatePublicationRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updatePublication', 'id', id);
      // verify required parameter 'updatePublicationRequest' is not null or undefined
      assertParamExists('updatePublication', 'updatePublicationRequest', updatePublicationRequest);
      const localVarPath = `/publications/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updatePublicationRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PublicationsApi - functional programming interface
 * @export
 */
export const PublicationsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PublicationsApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a new publication.
     * @summary Create publication
     * @param {CreatePublicationRequest} createPublicationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPublication(
      createPublicationRequest: CreatePublicationRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Publication>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createPublication(
        createPublicationRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['PublicationsApi.createPublication']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Delete a publication.
     * @summary Delete publication
     * @param {number} id Publication ID
     * @param {DeletePublicationDeleteOptionEnum} deleteOption Deletion method: 1 — delete everywhere, 2 — only in social network, 3 — only in Postmypost
     * @param {string} accountIds Comma-separated list of account IDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletePublication(
      id: number,
      deleteOption: DeletePublicationDeleteOptionEnum,
      accountIds: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Publication>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletePublication(
        id,
        deleteOption,
        accountIds,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['PublicationsApi.deletePublication']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieve publication data by its ID.
     * @summary Get publication by ID
     * @param {number} id Publication ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPublication(
      id: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Publication>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPublication(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['PublicationsApi.getPublication']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieve a list of all publications available in the system.
     * @summary Get list of publications
     * @param {number} projectId Project ID
     * @param {string} [postDate] Publication date (YYYY-MM-DD)
     * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [perPage] Number of items per page (maximum 50).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPublications(
      projectId: number,
      postDate?: string,
      sort?: string,
      page?: number,
      perPage?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicationsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPublications(
        projectId,
        postDate,
        sort,
        page,
        perPage,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['PublicationsApi.getPublications']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Update a publication by ID.
     * @summary Update publication
     * @param {number} id Publication ID
     * @param {UpdatePublicationRequest} updatePublicationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePublication(
      id: number,
      updatePublicationRequest: UpdatePublicationRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Publication>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatePublication(
        id,
        updatePublicationRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['PublicationsApi.updatePublication']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * PublicationsApi - factory interface
 * @export
 */
export const PublicationsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PublicationsApiFp(configuration);
  return {
    /**
     * Create a new publication.
     * @summary Create publication
     * @param {CreatePublicationRequest} createPublicationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPublication(
      createPublicationRequest: CreatePublicationRequest,
      options?: any,
    ): AxiosPromise<Publication> {
      return localVarFp
        .createPublication(createPublicationRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a publication.
     * @summary Delete publication
     * @param {number} id Publication ID
     * @param {DeletePublicationDeleteOptionEnum} deleteOption Deletion method: 1 — delete everywhere, 2 — only in social network, 3 — only in Postmypost
     * @param {string} accountIds Comma-separated list of account IDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePublication(
      id: number,
      deleteOption: DeletePublicationDeleteOptionEnum,
      accountIds: string,
      options?: any,
    ): AxiosPromise<Publication> {
      return localVarFp
        .deletePublication(id, deleteOption, accountIds, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieve publication data by its ID.
     * @summary Get publication by ID
     * @param {number} id Publication ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublication(id: number, options?: any): AxiosPromise<Publication> {
      return localVarFp.getPublication(id, options).then((request) => request(axios, basePath));
    },
    /**
     * Retrieve a list of all publications available in the system.
     * @summary Get list of publications
     * @param {number} projectId Project ID
     * @param {string} [postDate] Publication date (YYYY-MM-DD)
     * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [perPage] Number of items per page (maximum 50).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublications(
      projectId: number,
      postDate?: string,
      sort?: string,
      page?: number,
      perPage?: number,
      options?: any,
    ): AxiosPromise<PublicationsResponse> {
      return localVarFp
        .getPublications(projectId, postDate, sort, page, perPage, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update a publication by ID.
     * @summary Update publication
     * @param {number} id Publication ID
     * @param {UpdatePublicationRequest} updatePublicationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePublication(
      id: number,
      updatePublicationRequest: UpdatePublicationRequest,
      options?: any,
    ): AxiosPromise<Publication> {
      return localVarFp
        .updatePublication(id, updatePublicationRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PublicationsApi - object-oriented interface
 * @export
 * @class PublicationsApi
 * @extends {BaseAPI}
 */
export class PublicationsApi extends BaseAPI {
  /**
   * Create a new publication.
   * @summary Create publication
   * @param {CreatePublicationRequest} createPublicationRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicationsApi
   */
  public createPublication(
    createPublicationRequest: CreatePublicationRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return PublicationsApiFp(this.configuration)
      .createPublication(createPublicationRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a publication.
   * @summary Delete publication
   * @param {number} id Publication ID
   * @param {DeletePublicationDeleteOptionEnum} deleteOption Deletion method: 1 — delete everywhere, 2 — only in social network, 3 — only in Postmypost
   * @param {string} accountIds Comma-separated list of account IDs
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicationsApi
   */
  public deletePublication(
    id: number,
    deleteOption: DeletePublicationDeleteOptionEnum,
    accountIds: string,
    options?: RawAxiosRequestConfig,
  ) {
    return PublicationsApiFp(this.configuration)
      .deletePublication(id, deleteOption, accountIds, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve publication data by its ID.
   * @summary Get publication by ID
   * @param {number} id Publication ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicationsApi
   */
  public getPublication(id: number, options?: RawAxiosRequestConfig) {
    return PublicationsApiFp(this.configuration)
      .getPublication(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieve a list of all publications available in the system.
   * @summary Get list of publications
   * @param {number} projectId Project ID
   * @param {string} [postDate] Publication date (YYYY-MM-DD)
   * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;.
   * @param {number} [page] Page number (starts from 1).
   * @param {number} [perPage] Number of items per page (maximum 50).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicationsApi
   */
  public getPublications(
    projectId: number,
    postDate?: string,
    sort?: string,
    page?: number,
    perPage?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return PublicationsApiFp(this.configuration)
      .getPublications(projectId, postDate, sort, page, perPage, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update a publication by ID.
   * @summary Update publication
   * @param {number} id Publication ID
   * @param {UpdatePublicationRequest} updatePublicationRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PublicationsApi
   */
  public updatePublication(
    id: number,
    updatePublicationRequest: UpdatePublicationRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return PublicationsApiFp(this.configuration)
      .updatePublication(id, updatePublicationRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const DeletePublicationDeleteOptionEnum = {
  DELETE_EVERYWHERE: 1,
  DELETE_ONLY_IN_SOCIAL_NETWORK: 2,
  DELETE_ONLY_IN_POSTMYPOST: 3,
} as const;
export type DeletePublicationDeleteOptionEnum =
  (typeof DeletePublicationDeleteOptionEnum)[keyof typeof DeletePublicationDeleteOptionEnum];

/**
 * RubricsApi - axios parameter creator
 * @export
 */
export const RubricsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Retrieve a list of all available rubrics associated with the specified project.
     * @summary Get list of rubrics
     * @param {number} projectId Project ID
     * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [perPage] Number of items per page (maximum 50).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRubrics: async (
      projectId: number,
      sort?: string,
      page?: number,
      perPage?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists('getRubrics', 'projectId', projectId);
      const localVarPath = `/rubrics`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (projectId !== undefined) {
        localVarQueryParameter['project_id'] = projectId;
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter['per_page'] = perPage;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RubricsApi - functional programming interface
 * @export
 */
export const RubricsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RubricsApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieve a list of all available rubrics associated with the specified project.
     * @summary Get list of rubrics
     * @param {number} projectId Project ID
     * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [perPage] Number of items per page (maximum 50).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRubrics(
      projectId: number,
      sort?: string,
      page?: number,
      perPage?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RubricsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRubrics(
        projectId,
        sort,
        page,
        perPage,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['RubricsApi.getRubrics']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * RubricsApi - factory interface
 * @export
 */
export const RubricsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = RubricsApiFp(configuration);
  return {
    /**
     * Retrieve a list of all available rubrics associated with the specified project.
     * @summary Get list of rubrics
     * @param {number} projectId Project ID
     * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [perPage] Number of items per page (maximum 50).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRubrics(
      projectId: number,
      sort?: string,
      page?: number,
      perPage?: number,
      options?: any,
    ): AxiosPromise<RubricsResponse> {
      return localVarFp
        .getRubrics(projectId, sort, page, perPage, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * RubricsApi - object-oriented interface
 * @export
 * @class RubricsApi
 * @extends {BaseAPI}
 */
export class RubricsApi extends BaseAPI {
  /**
   * Retrieve a list of all available rubrics associated with the specified project.
   * @summary Get list of rubrics
   * @param {number} projectId Project ID
   * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;.
   * @param {number} [page] Page number (starts from 1).
   * @param {number} [perPage] Number of items per page (maximum 50).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RubricsApi
   */
  public getRubrics(
    projectId: number,
    sort?: string,
    page?: number,
    perPage?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return RubricsApiFp(this.configuration)
      .getRubrics(projectId, sort, page, perPage, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TimezonesApi - axios parameter creator
 * @export
 */
export const TimezonesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Retrieve a list of all timezones available in the system.
     * @summary Get list of timezones
     * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [perPage] Number of items per page (maximum 50).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTimezones: async (
      sort?: string,
      page?: number,
      perPage?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/timezones`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter['per_page'] = perPage;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TimezonesApi - functional programming interface
 * @export
 */
export const TimezonesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TimezonesApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieve a list of all timezones available in the system.
     * @summary Get list of timezones
     * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [perPage] Number of items per page (maximum 50).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTimezones(
      sort?: string,
      page?: number,
      perPage?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimezonesResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTimezones(
        sort,
        page,
        perPage,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TimezonesApi.getTimezones']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * TimezonesApi - factory interface
 * @export
 */
export const TimezonesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TimezonesApiFp(configuration);
  return {
    /**
     * Retrieve a list of all timezones available in the system.
     * @summary Get list of timezones
     * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;.
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [perPage] Number of items per page (maximum 50).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTimezones(
      sort?: string,
      page?: number,
      perPage?: number,
      options?: any,
    ): AxiosPromise<TimezonesResponse> {
      return localVarFp
        .getTimezones(sort, page, perPage, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TimezonesApi - object-oriented interface
 * @export
 * @class TimezonesApi
 * @extends {BaseAPI}
 */
export class TimezonesApi extends BaseAPI {
  /**
   * Retrieve a list of all timezones available in the system.
   * @summary Get list of timezones
   * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;.
   * @param {number} [page] Page number (starts from 1).
   * @param {number} [perPage] Number of items per page (maximum 50).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TimezonesApi
   */
  public getTimezones(
    sort?: string,
    page?: number,
    perPage?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return TimezonesApiFp(this.configuration)
      .getTimezones(sort, page, perPage, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UploadApi - axios parameter creator
 * @export
 */
export const UploadApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Completes the file upload process after the file has been successfully sent.
     * @summary Complete file upload
     * @param {number} id Upload ID obtained during initialization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeUpload: async (
      id: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('completeUpload', 'id', id);
      const localVarPath = `/upload/complete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Initializes the file upload process.
     * @summary Initialize file upload
     * @param {InitUploadRequest} initUploadRequest Initializes the file upload process. Requires one of the following parameter combinations: - &#x60;project_id&#x60; and &#x60;url&#x60; - &#x60;project_id&#x60;, &#x60;name&#x60;, and &#x60;size&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initUpload: async (
      initUploadRequest: InitUploadRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'initUploadRequest' is not null or undefined
      assertParamExists('initUpload', 'initUploadRequest', initUploadRequest);
      const localVarPath = `/upload/init`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        initUploadRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Checks the processing status of an uploaded file.
     * @summary Check file upload status
     * @param {number} id Upload ID obtained during initialization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statusUpload: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('statusUpload', 'id', id);
      const localVarPath = `/upload/status`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UploadApi - functional programming interface
 * @export
 */
export const UploadApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UploadApiAxiosParamCreator(configuration);
  return {
    /**
     * Completes the file upload process after the file has been successfully sent.
     * @summary Complete file upload
     * @param {number} id Upload ID obtained during initialization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async completeUpload(
      id: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadComplete>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.completeUpload(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UploadApi.completeUpload']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Initializes the file upload process.
     * @summary Initialize file upload
     * @param {InitUploadRequest} initUploadRequest Initializes the file upload process. Requires one of the following parameter combinations: - &#x60;project_id&#x60; and &#x60;url&#x60; - &#x60;project_id&#x60;, &#x60;name&#x60;, and &#x60;size&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async initUpload(
      initUploadRequest: InitUploadRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadInit>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.initUpload(
        initUploadRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UploadApi.initUpload']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Checks the processing status of an uploaded file.
     * @summary Check file upload status
     * @param {number} id Upload ID obtained during initialization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async statusUpload(
      id: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadStatus>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.statusUpload(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UploadApi.statusUpload']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * UploadApi - factory interface
 * @export
 */
export const UploadApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UploadApiFp(configuration);
  return {
    /**
     * Completes the file upload process after the file has been successfully sent.
     * @summary Complete file upload
     * @param {number} id Upload ID obtained during initialization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeUpload(id: number, options?: any): AxiosPromise<UploadComplete> {
      return localVarFp.completeUpload(id, options).then((request) => request(axios, basePath));
    },
    /**
     * Initializes the file upload process.
     * @summary Initialize file upload
     * @param {InitUploadRequest} initUploadRequest Initializes the file upload process. Requires one of the following parameter combinations: - &#x60;project_id&#x60; and &#x60;url&#x60; - &#x60;project_id&#x60;, &#x60;name&#x60;, and &#x60;size&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initUpload(initUploadRequest: InitUploadRequest, options?: any): AxiosPromise<UploadInit> {
      return localVarFp
        .initUpload(initUploadRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Checks the processing status of an uploaded file.
     * @summary Check file upload status
     * @param {number} id Upload ID obtained during initialization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statusUpload(id: number, options?: any): AxiosPromise<UploadStatus> {
      return localVarFp.statusUpload(id, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * UploadApi - object-oriented interface
 * @export
 * @class UploadApi
 * @extends {BaseAPI}
 */
export class UploadApi extends BaseAPI {
  /**
   * Completes the file upload process after the file has been successfully sent.
   * @summary Complete file upload
   * @param {number} id Upload ID obtained during initialization
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UploadApi
   */
  public completeUpload(id: number, options?: RawAxiosRequestConfig) {
    return UploadApiFp(this.configuration)
      .completeUpload(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Initializes the file upload process.
   * @summary Initialize file upload
   * @param {InitUploadRequest} initUploadRequest Initializes the file upload process. Requires one of the following parameter combinations: - &#x60;project_id&#x60; and &#x60;url&#x60; - &#x60;project_id&#x60;, &#x60;name&#x60;, and &#x60;size&#x60;
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UploadApi
   */
  public initUpload(initUploadRequest: InitUploadRequest, options?: RawAxiosRequestConfig) {
    return UploadApiFp(this.configuration)
      .initUpload(initUploadRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Checks the processing status of an uploaded file.
   * @summary Check file upload status
   * @param {number} id Upload ID obtained during initialization
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UploadApi
   */
  public statusUpload(id: number, options?: RawAxiosRequestConfig) {
    return UploadApiFp(this.configuration)
      .statusUpload(id, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
