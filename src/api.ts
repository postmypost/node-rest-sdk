/* tslint:disable */
/* eslint-disable */
/**
 * Postmypost REST API
 * Official OpenAPI specification for the Postmypost social media management (SMM) API.  Postmypost is a secure, reliable, and highly trusted social media management platform, recommended by thousands of SMM professionals and agencies. All integrations are built exclusively on official APIs, ensuring maximum security, compliance, and no risk of account blocking or bans.  With the Postmypost API, you can automate social media marketing, content scheduling, publishing, analytics, and workflow management across all major platforms, including Instagram, Facebook, Twitter, Threads, Bluesky, LinkedIn, Pinterest, YouTube, Rutube, TikTok, Discord, Reddit, VKontakte, Telegram, Viber, Odnoklassniki, Bitrix, Medium, Tumblr, Mastodon, and Webhook.  Why choose Postmypost? - 100% official and secure integrations with social networks - No risk of account blocking — all APIs are fully compliant - Trusted by thousands of businesses, agencies, and SMM professionals - Powerful automation, scheduling, and analytics tools - Friendly support and clear documentation  For agencies, businesses, and creators looking for the safest, most reliable way to automate and scale their social media presence, Postmypost is the recommended choice. 
 *
 * The version of the OpenAPI document: 4.1.7
 * Contact: support@postmypost.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface Account {
    /**
     * Account ID
     */
    'id': number;
    /**
     * Channel ID
     */
    'chanel_id': number;
    /**
     * Account ID in the channel
     */
    'external_id': string;
    /**
     * Account name
     */
    'name': string;
    /**
     * Account login
     */
    'login'?: string;
    'connection_status': AccountConnectionStatusEnum;
}


export interface AccountAnalytics {
    /**
     * Metric code
     */
    'type': string;
    /**
     * Metric title
     */
    'title': string;
    'data': Array<MetricValue>;
}
export interface AccountAnalyticsResponse {
    'data': Array<AccountAnalytics>;
}
/**
 * Account connection status: 1 — connected, 2 — authorization required 
 */

export const AccountConnectionStatusEnum = {
    CONNECTED: 1,
    AUTH_REQUIRED: 2
} as const;

export type AccountConnectionStatusEnum = typeof AccountConnectionStatusEnum[keyof typeof AccountConnectionStatusEnum];


export interface AccountsResponse {
    'data': Array<Account>;
    'pages': Pagination;
}
/**
 * @type Attachment
 * Attachment to a post
 */
export type Attachment = { type: 'image' } & ImageAttachment | { type: 'link' } & LinkAttachment | { type: 'video' } & VideoAttachment;

export interface BadRequestError {
    'name'?: string;
    'message'?: string;
    'code'?: number;
    'status'?: number;
}
export interface Channel {
    /**
     * Channel ID
     */
    'id': number;
    /**
     * Channel code
     */
    'code': string;
    /**
     * Channel name
     */
    'name': string;
}
export interface ChannelsResponse {
    'data': Array<Channel>;
    'pages': Pagination;
}
/**
 * Request to create a publication
 */
export interface CreatePublicationRequest {
    /**
     * Project ID
     */
    'project_id': number;
    /**
     * The scheduled or actual date and time when the post is (or was) published
     */
    'post_at': string;
    /**
     * The scheduled date and time for automatic deletion of the pos
     */
    'delete_at'?: string;
    /**
     * Rubric ID
     */
    'rubric_id'?: number;
    /**
     * List of account IDs where the publication will be posted
     */
    'account_ids': Array<number>;
    'publication_status': PublicationStatusEnumEdit;
    /**
     * Publication details for each account or group of accounts
     */
    'details': Array<PublicationDetailEditRequest>;
}


export interface ForbiddenError {
    'name'?: string;
    'message'?: string;
    'code'?: number;
    'status'?: number;
}
export interface ImageAttachment {
    'type': ImageAttachmentTypeEnum;
    'image': MediaFile;
    'preview': MediaFile;
}

export const ImageAttachmentTypeEnum = {
    Image: 'image'
} as const;

export type ImageAttachmentTypeEnum = typeof ImageAttachmentTypeEnum[keyof typeof ImageAttachmentTypeEnum];

/**
 * Request to initialize direct file upload
 */
export interface InitUploadByFileRequest {
    /**
     * ID Project
     */
    'project_id': number;
    /**
     * File name
     */
    'name': string;
    /**
     * File size in bytes
     */
    'size': number;
}
/**
 * Request to initialize file upload by URL
 */
export interface InitUploadByUrlRequest {
    /**
     * ID Project
     */
    'project_id': number;
    /**
     * File URL
     */
    'url': string;
}
/**
 * @type InitUploadRequest
 */
export type InitUploadRequest = InitUploadByFileRequest | InitUploadByUrlRequest;

export interface Link {
    /**
     * URL of the link
     */
    'url': string;
}
export interface LinkAttachment {
    'type': LinkAttachmentTypeEnum;
    'link': Link;
}

export const LinkAttachmentTypeEnum = {
    Link: 'link'
} as const;

export type LinkAttachmentTypeEnum = typeof LinkAttachmentTypeEnum[keyof typeof LinkAttachmentTypeEnum];

/**
 * Media file (image or video) used as an attachment
 */
export interface MediaFile {
    /**
     * File width in pixels
     */
    'width'?: number;
    /**
     * File height in pixels
     */
    'height'?: number;
    /**
     * URL to download or view the file
     */
    'url': string;
}
export interface MetricValue {
    /**
     * Metric date
     */
    'date': string;
    /**
     * Metric value for the date
     */
    'value': number;
}
export interface ModelError {
    /**
     * Error type
     */
    'name': string;
    /**
     * Human-readable error message
     */
    'message': string;
    /**
     * Application-specific error code
     */
    'code': number;
    /**
     * HTTP status code
     */
    'status': number;
}
export interface NotFoundError {
    'name'?: string;
    'message'?: string;
    'code'?: number;
    'status'?: number;
}
export interface Pagination {
    'page'?: number;
    'per_page'?: number;
    'total_pages'?: number;
    'total_count'?: number;
    'prev'?: number;
    'next'?: number;
}
export interface Project {
    /**
     * Project ID
     */
    'id': number;
    /**
     * Project name
     */
    'name': string;
    /**
     * Timezone ID
     */
    'timezone_id': number;
}
export interface ProjectsResponse {
    'data': Array<Project>;
    'pages': Pagination;
}
/**
 * Contains information about the publication, scheduled time, status, publication details, and the accounts where it is published
 */
export interface Publication {
    /**
     * Publication ID
     */
    'id': number;
    /**
     * The scheduled or actual date and time when the post is (or was) published
     */
    'post_at': string;
    /**
     * The scheduled date and time for automatic deletion of the pos
     */
    'delete_at'?: string;
    /**
     * Rubric ID
     */
    'rubric_id'?: number;
    /**
     * List of account IDs where the post will be published
     */
    'account_ids': Array<number>;
    /**
     * Publication details for each account or account group
     */
    'details': Array<PublicationDetail>;
    'publication_status': PublicationStatusEnum;
}


export interface PublicationAnalytics {
    /**
     * Publication ID
     */
    'id': string;
    /**
     * Chanel publication ID
     */
    'external_id'?: string;
    /**
     * Chanel publication URL
     */
    'external_url': string;
    /**
     * Post creation date and time
     */
    'created_at': string;
    /**
     * Post text
     */
    'content'?: string;
    /**
     * Metrics for the post (e.g. views, likes, comments, etc.)
     */
    'analytics': { [key: string]: number; };
    /**
     * Array of attachments
     */
    'attaches': Array<Attachment>;
    'type': PublicationAnalyticsTypeEnum;
}


export interface PublicationAnalyticsResponse {
    'data': Array<PublicationAnalytics>;
    'pages'?: Pagination;
}
/**
 * Publication Type: 1 — post, 3 — story, 4 — reels/shorts 
 */

export const PublicationAnalyticsTypeEnum = {
    TYPE_POST: 1,
    TYPE_STORY: 3,
    TYPE_REELS: 4
} as const;

export type PublicationAnalyticsTypeEnum = typeof PublicationAnalyticsTypeEnum[keyof typeof PublicationAnalyticsTypeEnum];


/**
 * Publication details for a specific account or platform
 */
export interface PublicationDetail {
    /**
     * Account ID
     */
    'account_id'?: number;
    /**
     * Publication text
     */
    'content'?: string;
    /**
     * First comment on the publication
     */
    'comment'?: string;
    /**
     * External link for the publication
     */
    'link'?: string;
    /**
     * Publication title
     */
    'title'?: string;
    /**
     * Allow comments on TikTok
     */
    'tiktok_comment'?: boolean;
    /**
     * Allow duets on TikTok
     */
    'tiktok_duet'?: boolean;
    /**
     * Allow stitch on TikTok
     */
    'tiktok_stitch'?: boolean;
    'tiktok_privacy_status'?: PublicationDetailTikTokPrivacyStatusEnum;
    'youtube_privacy_status'?: PublicationDetailYouTubePrivacyStatusEnum;
    'x_reply_settings'?: PublicationDetailXReplySettingsEnum;
    /**
     * Share to Instagram feed
     */
    'instagram_share_to_feed'?: boolean;
    /**
     * Not safe for work flag
     */
    'nsfw'?: boolean;
    /**
     * List of files attached to the publication
     */
    'files'?: Array<PublicationFileResponseEnum>;
    'publication_type': PublicationDetailPublicationTypeEnum;
}


/**
 * Parameters for creating or updating publication details
 */
export interface PublicationDetailEditRequest {
    /**
     * Account ID
     */
    'account_id'?: number;
    'publication_type': PublicationDetailPublicationTypeEnum;
    /**
     * Publication text
     */
    'content'?: string;
    /**
     * First comment on the publication
     */
    'comment'?: string;
    /**
     * External link for the publication
     */
    'link'?: string;
    /**
     * Publication title
     */
    'title'?: string;
    /**
     * Allow comments on TikTok
     */
    'tiktok_comment'?: boolean;
    /**
     * Allow duets on TikTok
     */
    'tiktok_duet'?: boolean;
    /**
     * Allow stitch on TikTok
     */
    'tiktok_stitch'?: boolean;
    'tiktok_privacy_status'?: PublicationDetailTikTokPrivacyStatusEnum;
    'youtube_privacy_status'?: PublicationDetailYouTubePrivacyStatusEnum;
    'x_reply_settings'?: PublicationDetailXReplySettingsEnum;
    /**
     * Share to Instagram feed
     */
    'instagram_share_to_feed'?: boolean;
    /**
     * Not safe for work flag
     */
    'nsfw'?: boolean;
    /**
     * File IDs
     */
    'file_ids'?: Array<number>;
}
/**
 * Publication type: 1 — post, 2 — story, 4 — reels/shorts/clips 
 */

export const PublicationDetailPublicationTypeEnum = {
    POST: 1,
    STORY: 2,
    REELS_SHORTS_CLIPS: 4
} as const;

export type PublicationDetailPublicationTypeEnum = typeof PublicationDetailPublicationTypeEnum[keyof typeof PublicationDetailPublicationTypeEnum];


/**
 * TikTok publication privacy: 1 — public, 2 — friends, 3 — private 
 */

export const PublicationDetailTikTokPrivacyStatusEnum = {
    PUBLIC: 1,
    FRIENDS: 2,
    PRIVATE: 3
} as const;

export type PublicationDetailTikTokPrivacyStatusEnum = typeof PublicationDetailTikTokPrivacyStatusEnum[keyof typeof PublicationDetailTikTokPrivacyStatusEnum];


/**
 * X reply settings: 1 — Everyone, 2 — Following, 3 — Mentioned users 
 */

export const PublicationDetailXReplySettingsEnum = {
    EVERYONE: 1,
    FOLLOWING: 2,
    MENTIONED_USERS: 3
} as const;

export type PublicationDetailXReplySettingsEnum = typeof PublicationDetailXReplySettingsEnum[keyof typeof PublicationDetailXReplySettingsEnum];


/**
 * YouTube publication privacy: 1 — public, 2 — unlisted, 3 — private 
 */

export const PublicationDetailYouTubePrivacyStatusEnum = {
    PUBLIC: 1,
    UNLISTED: 2,
    PRIVATE: 3
} as const;

export type PublicationDetailYouTubePrivacyStatusEnum = typeof PublicationDetailYouTubePrivacyStatusEnum[keyof typeof PublicationDetailYouTubePrivacyStatusEnum];


export interface PublicationEdit {
    /**
     * Publication ID
     */
    'id': number;
    /**
     * The scheduled or actual date and time when the post is (or was) published
     */
    'post_at': string;
    /**
     * The scheduled date and time for automatic deletion of the pos
     */
    'delete_at'?: string;
    /**
     * Rubric ID
     */
    'rubric_id'?: number;
    /**
     * List of account IDs where the post will be published
     */
    'account_ids': Array<number>;
    /**
     * Publication details for each account or account group
     */
    'details': Array<PublicationDetail>;
    'publication_status': PublicationStatusEnumEdit;
}


/**
 * Object representing a file attached to a publication
 */
export interface PublicationFileResponseEnum {
    /**
     * File ID
     */
    'id'?: number;
    /**
     * File URL
     */
    'original'?: string;
}
/**
 * Publication status: 0 — deleted, 1 — published, 2 — publishing, 3 — error, 4 — draft, 5 — pending publication, 6 — not deleted due to error, 10 — template, 11 — workflow stage, 12 — approval 
 */

export const PublicationStatusEnum = {
    DELETED: 0,
    PUBLISHED: 1,
    PUBLISHING: 2,
    ERROR: 3,
    DRAFT: 4,
    PENDING_PUBLICATION: 5,
    NOT_DELETED_DUE_TO_ERROR: 6,
    TEMPLATE: 10,
    WORKFLOW_STAGE: 11,
    APPROVAL: 12
} as const;

export type PublicationStatusEnum = typeof PublicationStatusEnum[keyof typeof PublicationStatusEnum];


/**
 * Statuses allowed for creation and update: 4 — draft, 5 — pending publication, 10 — template, 11 — workflow stage, 12 — approval 
 */

export const PublicationStatusEnumEdit = {
    DRAFT: 4,
    PENDING_PUBLICATION: 5,
    TEMPLATE: 10,
    WORKFLOW_STAGE: 11,
    APPROVAL: 12
} as const;

export type PublicationStatusEnumEdit = typeof PublicationStatusEnumEdit[keyof typeof PublicationStatusEnumEdit];


export interface PublicationsResponse {
    'data': Array<Publication>;
    'pages': Pagination;
}
export interface Rubric {
    /**
     * Rubric ID
     */
    'id': number;
    /**
     * Rubric name
     */
    'name': string;
}
export interface RubricsResponse {
    'data': Array<Rubric>;
    'pages': Pagination;
}
export interface Timezone {
    /**
     * Timezone ID
     */
    'id': number;
    /**
     * Timezone name
     */
    'name': string;
    /**
     * Offset relative to UTC+0
     */
    'utc_offset': number;
}
export interface TimezonesResponse {
    'data': Array<Timezone>;
    'pages': Pagination;
}
export interface UnauthorizedError {
    'name'?: string;
    'message'?: string;
    'code'?: number;
    'status'?: number;
}
export interface UnprocessableEntityError {
    'name'?: string;
    'message'?: string;
    'code'?: number;
    'status'?: number;
}
/**
 * Request to update a publication
 */
export interface UpdatePublicationRequest {
    /**
     * The scheduled or actual date and time when the post is (or was) published
     */
    'post_at': string;
    /**
     * The scheduled date and time for automatic deletion of the pos
     */
    'delete_at'?: string;
    /**
     * Rubric ID
     */
    'rubric_id'?: number;
    /**
     * List of account IDs where the publication will be posted
     */
    'account_ids': Array<number>;
    'publication_status': PublicationStatusEnumEdit;
    /**
     * Publication details for each account or group of accounts
     */
    'details': Array<PublicationDetailEditRequest>;
}


/**
 * Parameters required for direct file upload to storage (e.g., S3).
 */
export interface UploadByFile {
    /**
     * Upload ID
     */
    'id': number;
    /**
     * File name
     */
    'name': string;
    /**
     * File size in bytes
     */
    'size': number;
    /**
     * Upload endpoint URL
     */
    'action': string;
    /**
     * Parameters to be submitted with the file during upload
     */
    'fields': Array<UploadByFileFieldsInner>;
    'status': UploadStatusEnum;
}


export interface UploadByFileFieldsInner {
    'key'?: string;
    'value'?: string;
}
/**
 * Details of a successfully uploaded file.
 */
export interface UploadByUrl {
    /**
     * Upload ID
     */
    'id': number;
    /**
     * URL of the uploaded file
     */
    'url': string;
    /**
     * File size in bytes
     */
    'size': number;
    'status': UploadStatusEnum;
}


export interface UploadComplete {
    /**
     * Upload ID
     */
    'id': number;
    'status': UploadStatusEnum;
}


/**
 * @type UploadInit
 */
export type UploadInit = UploadByFile | UploadByUrl;

export interface UploadStatus {
    /**
     * Upload ID
     */
    'id': number;
    /**
     * File ID
     */
    'file_id'?: number;
    'status': UploadStatusEnum;
}


/**
 * Upload status: 5 — waiting for upload, 4 — uploading, 3 — processing, 2 — error, 1 — file uploaded successfully 
 */

export const UploadStatusEnum = {
    FILE_UPLOADED_SUCCESSFULLY: 1,
    ERROR: 2,
    PROCESSING: 3,
    UPLOADING: 4,
    WAITING_FOR_UPLOAD: 5
} as const;

export type UploadStatusEnum = typeof UploadStatusEnum[keyof typeof UploadStatusEnum];


export interface VideoAttachment {
    'type': VideoAttachmentTypeEnum;
    'video': MediaFile;
    'preview': MediaFile;
}

export const VideoAttachmentTypeEnum = {
    Video: 'video'
} as const;

export type VideoAttachmentTypeEnum = typeof VideoAttachmentTypeEnum[keyof typeof VideoAttachmentTypeEnum];


/**
 * AccountsApi - axios parameter creator
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a list of all accounts associated with the specified project.
         * @summary Get list of accounts
         * @param {number} projectId Project ID
         * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;. 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [perPage] Number of items per page (maximum 50).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts: async (projectId: number, sort?: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getAccounts', 'projectId', projectId)
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a list of all accounts associated with the specified project.
         * @summary Get list of accounts
         * @param {number} projectId Project ID
         * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;. 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [perPage] Number of items per page (maximum 50).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccounts(projectId: number, sort?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccounts(projectId, sort, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.getAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountsApi - factory interface
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * Retrieve a list of all accounts associated with the specified project.
         * @summary Get list of accounts
         * @param {number} projectId Project ID
         * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;. 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [perPage] Number of items per page (maximum 50).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(projectId: number, sort?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<AccountsResponse> {
            return localVarFp.getAccounts(projectId, sort, page, perPage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 */
export class AccountsApi extends BaseAPI {
    /**
     * Retrieve a list of all accounts associated with the specified project.
     * @summary Get list of accounts
     * @param {number} projectId Project ID
     * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;. 
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [perPage] Number of items per page (maximum 50).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAccounts(projectId: number, sort?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccounts(projectId, sort, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AnalyticsApi - axios parameter creator
 */
export const AnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve account metrics (e.g., number of followers) for a specified period.
         * @summary Get account analytics
         * @param {number} projectId Project ID
         * @param {string} accountId Account ID
         * @param {string} dateFrom Start date of the period (YYYY-MM-DD)
         * @param {string} dateTo End date of the period (YYYY-MM-DD)
         * @param {string} metrics Comma-separated list of metrics (e.g., followers,subscribed)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalyticsAccounts: async (projectId: number, accountId: string, dateFrom: string, dateTo: string, metrics: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getAnalyticsAccounts', 'projectId', projectId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAnalyticsAccounts', 'accountId', accountId)
            // verify required parameter 'dateFrom' is not null or undefined
            assertParamExists('getAnalyticsAccounts', 'dateFrom', dateFrom)
            // verify required parameter 'dateTo' is not null or undefined
            assertParamExists('getAnalyticsAccounts', 'dateTo', dateTo)
            // verify required parameter 'metrics' is not null or undefined
            assertParamExists('getAnalyticsAccounts', 'metrics', metrics)
            const localVarPath = `/analytics/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['date_from'] = (dateFrom as any instanceof Date) ?
                    (dateFrom as any).toISOString().substring(0,10) :
                    dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['date_to'] = (dateTo as any instanceof Date) ?
                    (dateTo as any).toISOString().substring(0,10) :
                    dateTo;
            }

            if (metrics !== undefined) {
                localVarQueryParameter['metrics'] = metrics;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve post analytics by account and project for a specified period.
         * @summary Get publications analytics
         * @param {number} projectId Project ID
         * @param {string} accountId Account ID
         * @param {string} dateFrom Start date of the period (YYYY-MM-DD)
         * @param {string} dateTo End date of the period (YYYY-MM-DD)
         * @param {GetAnalyticsPublicationsTypeEnum} [type] Publication Type: 1 — post, 3 — story, 4 — reels/shorts 
         * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;. 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [perPage] Number of items per page (maximum 50).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalyticsPublications: async (projectId: number, accountId: string, dateFrom: string, dateTo: string, type?: GetAnalyticsPublicationsTypeEnum, sort?: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getAnalyticsPublications', 'projectId', projectId)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAnalyticsPublications', 'accountId', accountId)
            // verify required parameter 'dateFrom' is not null or undefined
            assertParamExists('getAnalyticsPublications', 'dateFrom', dateFrom)
            // verify required parameter 'dateTo' is not null or undefined
            assertParamExists('getAnalyticsPublications', 'dateTo', dateTo)
            const localVarPath = `/analytics/publications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (dateFrom !== undefined) {
                localVarQueryParameter['date_from'] = (dateFrom as any instanceof Date) ?
                    (dateFrom as any).toISOString().substring(0,10) :
                    dateFrom;
            }

            if (dateTo !== undefined) {
                localVarQueryParameter['date_to'] = (dateTo as any instanceof Date) ?
                    (dateTo as any).toISOString().substring(0,10) :
                    dateTo;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalyticsApi - functional programming interface
 */
export const AnalyticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnalyticsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve account metrics (e.g., number of followers) for a specified period.
         * @summary Get account analytics
         * @param {number} projectId Project ID
         * @param {string} accountId Account ID
         * @param {string} dateFrom Start date of the period (YYYY-MM-DD)
         * @param {string} dateTo End date of the period (YYYY-MM-DD)
         * @param {string} metrics Comma-separated list of metrics (e.g., followers,subscribed)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnalyticsAccounts(projectId: number, accountId: string, dateFrom: string, dateTo: string, metrics: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountAnalyticsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnalyticsAccounts(projectId, accountId, dateFrom, dateTo, metrics, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getAnalyticsAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve post analytics by account and project for a specified period.
         * @summary Get publications analytics
         * @param {number} projectId Project ID
         * @param {string} accountId Account ID
         * @param {string} dateFrom Start date of the period (YYYY-MM-DD)
         * @param {string} dateTo End date of the period (YYYY-MM-DD)
         * @param {GetAnalyticsPublicationsTypeEnum} [type] Publication Type: 1 — post, 3 — story, 4 — reels/shorts 
         * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;. 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [perPage] Number of items per page (maximum 50).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnalyticsPublications(projectId: number, accountId: string, dateFrom: string, dateTo: string, type?: GetAnalyticsPublicationsTypeEnum, sort?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicationAnalyticsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnalyticsPublications(projectId, accountId, dateFrom, dateTo, type, sort, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getAnalyticsPublications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnalyticsApi - factory interface
 */
export const AnalyticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnalyticsApiFp(configuration)
    return {
        /**
         * Retrieve account metrics (e.g., number of followers) for a specified period.
         * @summary Get account analytics
         * @param {number} projectId Project ID
         * @param {string} accountId Account ID
         * @param {string} dateFrom Start date of the period (YYYY-MM-DD)
         * @param {string} dateTo End date of the period (YYYY-MM-DD)
         * @param {string} metrics Comma-separated list of metrics (e.g., followers,subscribed)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalyticsAccounts(projectId: number, accountId: string, dateFrom: string, dateTo: string, metrics: string, options?: RawAxiosRequestConfig): AxiosPromise<AccountAnalyticsResponse> {
            return localVarFp.getAnalyticsAccounts(projectId, accountId, dateFrom, dateTo, metrics, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve post analytics by account and project for a specified period.
         * @summary Get publications analytics
         * @param {number} projectId Project ID
         * @param {string} accountId Account ID
         * @param {string} dateFrom Start date of the period (YYYY-MM-DD)
         * @param {string} dateTo End date of the period (YYYY-MM-DD)
         * @param {GetAnalyticsPublicationsTypeEnum} [type] Publication Type: 1 — post, 3 — story, 4 — reels/shorts 
         * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;. 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [perPage] Number of items per page (maximum 50).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalyticsPublications(projectId: number, accountId: string, dateFrom: string, dateTo: string, type?: GetAnalyticsPublicationsTypeEnum, sort?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<PublicationAnalyticsResponse> {
            return localVarFp.getAnalyticsPublications(projectId, accountId, dateFrom, dateTo, type, sort, page, perPage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalyticsApi - object-oriented interface
 */
export class AnalyticsApi extends BaseAPI {
    /**
     * Retrieve account metrics (e.g., number of followers) for a specified period.
     * @summary Get account analytics
     * @param {number} projectId Project ID
     * @param {string} accountId Account ID
     * @param {string} dateFrom Start date of the period (YYYY-MM-DD)
     * @param {string} dateTo End date of the period (YYYY-MM-DD)
     * @param {string} metrics Comma-separated list of metrics (e.g., followers,subscribed)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAnalyticsAccounts(projectId: number, accountId: string, dateFrom: string, dateTo: string, metrics: string, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getAnalyticsAccounts(projectId, accountId, dateFrom, dateTo, metrics, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve post analytics by account and project for a specified period.
     * @summary Get publications analytics
     * @param {number} projectId Project ID
     * @param {string} accountId Account ID
     * @param {string} dateFrom Start date of the period (YYYY-MM-DD)
     * @param {string} dateTo End date of the period (YYYY-MM-DD)
     * @param {GetAnalyticsPublicationsTypeEnum} [type] Publication Type: 1 — post, 3 — story, 4 — reels/shorts 
     * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;. 
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [perPage] Number of items per page (maximum 50).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAnalyticsPublications(projectId: number, accountId: string, dateFrom: string, dateTo: string, type?: GetAnalyticsPublicationsTypeEnum, sort?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getAnalyticsPublications(projectId, accountId, dateFrom, dateTo, type, sort, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetAnalyticsPublicationsTypeEnum = {
    TYPE_POST: 1,
    TYPE_STORY: 3,
    TYPE_REELS: 4
} as const;
export type GetAnalyticsPublicationsTypeEnum = typeof GetAnalyticsPublicationsTypeEnum[keyof typeof GetAnalyticsPublicationsTypeEnum];


/**
 * ChannelsApi - axios parameter creator
 */
export const ChannelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a list of all available channels in the system.
         * @summary Get list of channels
         * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;. 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [perPage] Number of items per page (maximum 50).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannels: async (sort?: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChannelsApi - functional programming interface
 */
export const ChannelsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChannelsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a list of all available channels in the system.
         * @summary Get list of channels
         * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;. 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [perPage] Number of items per page (maximum 50).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannels(sort?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChannels(sort, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChannelsApi.getChannels']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChannelsApi - factory interface
 */
export const ChannelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChannelsApiFp(configuration)
    return {
        /**
         * Retrieve a list of all available channels in the system.
         * @summary Get list of channels
         * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;. 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [perPage] Number of items per page (maximum 50).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannels(sort?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<ChannelsResponse> {
            return localVarFp.getChannels(sort, page, perPage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChannelsApi - object-oriented interface
 */
export class ChannelsApi extends BaseAPI {
    /**
     * Retrieve a list of all available channels in the system.
     * @summary Get list of channels
     * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;. 
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [perPage] Number of items per page (maximum 50).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getChannels(sort?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return ChannelsApiFp(this.configuration).getChannels(sort, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectsApi - axios parameter creator
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a list of all projects available for your account.
         * @summary Get list of projects
         * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;. 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [perPage] Number of items per page (maximum 50).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjects: async (sort?: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a list of all projects available for your account.
         * @summary Get list of projects
         * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;. 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [perPage] Number of items per page (maximum 50).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjects(sort?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjects(sort, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.getProjects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectsApi - factory interface
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * Retrieve a list of all projects available for your account.
         * @summary Get list of projects
         * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;. 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [perPage] Number of items per page (maximum 50).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjects(sort?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<ProjectsResponse> {
            return localVarFp.getProjects(sort, page, perPage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 */
export class ProjectsApi extends BaseAPI {
    /**
     * Retrieve a list of all projects available for your account.
     * @summary Get list of projects
     * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;. 
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [perPage] Number of items per page (maximum 50).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getProjects(sort?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).getProjects(sort, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PublicationsApi - axios parameter creator
 */
export const PublicationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new publication.
         * @summary Create publication
         * @param {CreatePublicationRequest} createPublicationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublication: async (createPublicationRequest: CreatePublicationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPublicationRequest' is not null or undefined
            assertParamExists('createPublication', 'createPublicationRequest', createPublicationRequest)
            const localVarPath = `/publications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPublicationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a publication.
         * @summary Delete publication
         * @param {number} id Publication ID
         * @param {DeletePublicationDeleteOptionEnum} deleteOption Deletion method: 1 — delete everywhere, 2 — only in social network, 3 — only in Postmypost 
         * @param {string} accountIds Comma-separated list of account IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublication: async (id: number, deleteOption: DeletePublicationDeleteOptionEnum, accountIds: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePublication', 'id', id)
            // verify required parameter 'deleteOption' is not null or undefined
            assertParamExists('deletePublication', 'deleteOption', deleteOption)
            // verify required parameter 'accountIds' is not null or undefined
            assertParamExists('deletePublication', 'accountIds', accountIds)
            const localVarPath = `/publications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (deleteOption !== undefined) {
                localVarQueryParameter['delete_option'] = deleteOption;
            }

            if (accountIds !== undefined) {
                localVarQueryParameter['account_ids'] = accountIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve publication data by its ID.
         * @summary Get publication by ID
         * @param {number} id Publication ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublication: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPublication', 'id', id)
            const localVarPath = `/publications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all publications available in the system.
         * @summary Get list of publications
         * @param {number} projectId Project ID
         * @param {string} [postDate] Publication date (YYYY-MM-DD)
         * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;. 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [perPage] Number of items per page (maximum 50).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublications: async (projectId: number, postDate?: string, sort?: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getPublications', 'projectId', projectId)
            const localVarPath = `/publications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (postDate !== undefined) {
                localVarQueryParameter['post_date'] = (postDate as any instanceof Date) ?
                    (postDate as any).toISOString().substring(0,10) :
                    postDate;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a publication by ID.
         * @summary Update publication
         * @param {number} id Publication ID
         * @param {UpdatePublicationRequest} updatePublicationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublication: async (id: number, updatePublicationRequest: UpdatePublicationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePublication', 'id', id)
            // verify required parameter 'updatePublicationRequest' is not null or undefined
            assertParamExists('updatePublication', 'updatePublicationRequest', updatePublicationRequest)
            const localVarPath = `/publications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePublicationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicationsApi - functional programming interface
 */
export const PublicationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new publication.
         * @summary Create publication
         * @param {CreatePublicationRequest} createPublicationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPublication(createPublicationRequest: CreatePublicationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Publication>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPublication(createPublicationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicationsApi.createPublication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a publication.
         * @summary Delete publication
         * @param {number} id Publication ID
         * @param {DeletePublicationDeleteOptionEnum} deleteOption Deletion method: 1 — delete everywhere, 2 — only in social network, 3 — only in Postmypost 
         * @param {string} accountIds Comma-separated list of account IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePublication(id: number, deleteOption: DeletePublicationDeleteOptionEnum, accountIds: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Publication>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePublication(id, deleteOption, accountIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicationsApi.deletePublication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve publication data by its ID.
         * @summary Get publication by ID
         * @param {number} id Publication ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublication(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Publication>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublication(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicationsApi.getPublication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all publications available in the system.
         * @summary Get list of publications
         * @param {number} projectId Project ID
         * @param {string} [postDate] Publication date (YYYY-MM-DD)
         * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;. 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [perPage] Number of items per page (maximum 50).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublications(projectId: number, postDate?: string, sort?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublications(projectId, postDate, sort, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicationsApi.getPublications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a publication by ID.
         * @summary Update publication
         * @param {number} id Publication ID
         * @param {UpdatePublicationRequest} updatePublicationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePublication(id: number, updatePublicationRequest: UpdatePublicationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Publication>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePublication(id, updatePublicationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicationsApi.updatePublication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PublicationsApi - factory interface
 */
export const PublicationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicationsApiFp(configuration)
    return {
        /**
         * Create a new publication.
         * @summary Create publication
         * @param {CreatePublicationRequest} createPublicationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublication(createPublicationRequest: CreatePublicationRequest, options?: RawAxiosRequestConfig): AxiosPromise<Publication> {
            return localVarFp.createPublication(createPublicationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a publication.
         * @summary Delete publication
         * @param {number} id Publication ID
         * @param {DeletePublicationDeleteOptionEnum} deleteOption Deletion method: 1 — delete everywhere, 2 — only in social network, 3 — only in Postmypost 
         * @param {string} accountIds Comma-separated list of account IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublication(id: number, deleteOption: DeletePublicationDeleteOptionEnum, accountIds: string, options?: RawAxiosRequestConfig): AxiosPromise<Publication> {
            return localVarFp.deletePublication(id, deleteOption, accountIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve publication data by its ID.
         * @summary Get publication by ID
         * @param {number} id Publication ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublication(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Publication> {
            return localVarFp.getPublication(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all publications available in the system.
         * @summary Get list of publications
         * @param {number} projectId Project ID
         * @param {string} [postDate] Publication date (YYYY-MM-DD)
         * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;. 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [perPage] Number of items per page (maximum 50).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublications(projectId: number, postDate?: string, sort?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<PublicationsResponse> {
            return localVarFp.getPublications(projectId, postDate, sort, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a publication by ID.
         * @summary Update publication
         * @param {number} id Publication ID
         * @param {UpdatePublicationRequest} updatePublicationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublication(id: number, updatePublicationRequest: UpdatePublicationRequest, options?: RawAxiosRequestConfig): AxiosPromise<Publication> {
            return localVarFp.updatePublication(id, updatePublicationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PublicationsApi - object-oriented interface
 */
export class PublicationsApi extends BaseAPI {
    /**
     * Create a new publication.
     * @summary Create publication
     * @param {CreatePublicationRequest} createPublicationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createPublication(createPublicationRequest: CreatePublicationRequest, options?: RawAxiosRequestConfig) {
        return PublicationsApiFp(this.configuration).createPublication(createPublicationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a publication.
     * @summary Delete publication
     * @param {number} id Publication ID
     * @param {DeletePublicationDeleteOptionEnum} deleteOption Deletion method: 1 — delete everywhere, 2 — only in social network, 3 — only in Postmypost 
     * @param {string} accountIds Comma-separated list of account IDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deletePublication(id: number, deleteOption: DeletePublicationDeleteOptionEnum, accountIds: string, options?: RawAxiosRequestConfig) {
        return PublicationsApiFp(this.configuration).deletePublication(id, deleteOption, accountIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve publication data by its ID.
     * @summary Get publication by ID
     * @param {number} id Publication ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPublication(id: number, options?: RawAxiosRequestConfig) {
        return PublicationsApiFp(this.configuration).getPublication(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all publications available in the system.
     * @summary Get list of publications
     * @param {number} projectId Project ID
     * @param {string} [postDate] Publication date (YYYY-MM-DD)
     * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;. 
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [perPage] Number of items per page (maximum 50).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPublications(projectId: number, postDate?: string, sort?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return PublicationsApiFp(this.configuration).getPublications(projectId, postDate, sort, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a publication by ID.
     * @summary Update publication
     * @param {number} id Publication ID
     * @param {UpdatePublicationRequest} updatePublicationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updatePublication(id: number, updatePublicationRequest: UpdatePublicationRequest, options?: RawAxiosRequestConfig) {
        return PublicationsApiFp(this.configuration).updatePublication(id, updatePublicationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

export const DeletePublicationDeleteOptionEnum = {
    DELETE_EVERYWHERE: 1,
    DELETE_ONLY_IN_SOCIAL_NETWORK: 2,
    DELETE_ONLY_IN_POSTMYPOST: 3
} as const;
export type DeletePublicationDeleteOptionEnum = typeof DeletePublicationDeleteOptionEnum[keyof typeof DeletePublicationDeleteOptionEnum];


/**
 * RubricsApi - axios parameter creator
 */
export const RubricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a list of all available rubrics associated with the specified project.
         * @summary Get list of rubrics
         * @param {number} projectId Project ID
         * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;. 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [perPage] Number of items per page (maximum 50).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRubrics: async (projectId: number, sort?: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getRubrics', 'projectId', projectId)
            const localVarPath = `/rubrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RubricsApi - functional programming interface
 */
export const RubricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RubricsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a list of all available rubrics associated with the specified project.
         * @summary Get list of rubrics
         * @param {number} projectId Project ID
         * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;. 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [perPage] Number of items per page (maximum 50).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRubrics(projectId: number, sort?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RubricsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRubrics(projectId, sort, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RubricsApi.getRubrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RubricsApi - factory interface
 */
export const RubricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RubricsApiFp(configuration)
    return {
        /**
         * Retrieve a list of all available rubrics associated with the specified project.
         * @summary Get list of rubrics
         * @param {number} projectId Project ID
         * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;. 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [perPage] Number of items per page (maximum 50).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRubrics(projectId: number, sort?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<RubricsResponse> {
            return localVarFp.getRubrics(projectId, sort, page, perPage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RubricsApi - object-oriented interface
 */
export class RubricsApi extends BaseAPI {
    /**
     * Retrieve a list of all available rubrics associated with the specified project.
     * @summary Get list of rubrics
     * @param {number} projectId Project ID
     * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;. 
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [perPage] Number of items per page (maximum 50).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRubrics(projectId: number, sort?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return RubricsApiFp(this.configuration).getRubrics(projectId, sort, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TimezonesApi - axios parameter creator
 */
export const TimezonesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a list of all timezones available in the system.
         * @summary Get list of timezones
         * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;. 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [perPage] Number of items per page (maximum 50).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimezones: async (sort?: string, page?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/timezones`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimezonesApi - functional programming interface
 */
export const TimezonesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TimezonesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a list of all timezones available in the system.
         * @summary Get list of timezones
         * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;. 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [perPage] Number of items per page (maximum 50).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimezones(sort?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimezonesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimezones(sort, page, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimezonesApi.getTimezones']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TimezonesApi - factory interface
 */
export const TimezonesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TimezonesApiFp(configuration)
    return {
        /**
         * Retrieve a list of all timezones available in the system.
         * @summary Get list of timezones
         * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;. 
         * @param {number} [page] Page number (starts from 1).
         * @param {number} [perPage] Number of items per page (maximum 50).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimezones(sort?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig): AxiosPromise<TimezonesResponse> {
            return localVarFp.getTimezones(sort, page, perPage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TimezonesApi - object-oriented interface
 */
export class TimezonesApi extends BaseAPI {
    /**
     * Retrieve a list of all timezones available in the system.
     * @summary Get list of timezones
     * @param {string} [sort] List sorting parameter. Format: &#x60;sort&#x3D;field&#x60; — ascending by field, &#x60;sort&#x3D;-field&#x60; — descending by field. Multiple fields can be specified separated by a comma: &#x60;sort&#x3D;field,-another_field&#x60;. 
     * @param {number} [page] Page number (starts from 1).
     * @param {number} [perPage] Number of items per page (maximum 50).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTimezones(sort?: string, page?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return TimezonesApiFp(this.configuration).getTimezones(sort, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UploadApi - axios parameter creator
 */
export const UploadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Completes the file upload process after the file has been successfully sent.
         * @summary Complete file upload
         * @param {number} id Upload ID obtained during initialization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeUpload: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('completeUpload', 'id', id)
            const localVarPath = `/upload/complete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initializes the file upload process.
         * @summary Initialize file upload
         * @param {InitUploadRequest} initUploadRequest Initializes the file upload process. Requires one of the following parameter combinations: - &#x60;project_id&#x60; and &#x60;url&#x60; - &#x60;project_id&#x60;, &#x60;name&#x60;, and &#x60;size&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initUpload: async (initUploadRequest: InitUploadRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'initUploadRequest' is not null or undefined
            assertParamExists('initUpload', 'initUploadRequest', initUploadRequest)
            const localVarPath = `/upload/init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(initUploadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks the processing status of an uploaded file.
         * @summary Check file upload status
         * @param {number} id Upload ID obtained during initialization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusUpload: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('statusUpload', 'id', id)
            const localVarPath = `/upload/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UploadApi - functional programming interface
 */
export const UploadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UploadApiAxiosParamCreator(configuration)
    return {
        /**
         * Completes the file upload process after the file has been successfully sent.
         * @summary Complete file upload
         * @param {number} id Upload ID obtained during initialization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeUpload(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadComplete>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeUpload(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.completeUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Initializes the file upload process.
         * @summary Initialize file upload
         * @param {InitUploadRequest} initUploadRequest Initializes the file upload process. Requires one of the following parameter combinations: - &#x60;project_id&#x60; and &#x60;url&#x60; - &#x60;project_id&#x60;, &#x60;name&#x60;, and &#x60;size&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initUpload(initUploadRequest: InitUploadRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadInit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initUpload(initUploadRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.initUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Checks the processing status of an uploaded file.
         * @summary Check file upload status
         * @param {number} id Upload ID obtained during initialization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusUpload(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusUpload(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.statusUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UploadApi - factory interface
 */
export const UploadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UploadApiFp(configuration)
    return {
        /**
         * Completes the file upload process after the file has been successfully sent.
         * @summary Complete file upload
         * @param {number} id Upload ID obtained during initialization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeUpload(id: number, options?: RawAxiosRequestConfig): AxiosPromise<UploadComplete> {
            return localVarFp.completeUpload(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Initializes the file upload process.
         * @summary Initialize file upload
         * @param {InitUploadRequest} initUploadRequest Initializes the file upload process. Requires one of the following parameter combinations: - &#x60;project_id&#x60; and &#x60;url&#x60; - &#x60;project_id&#x60;, &#x60;name&#x60;, and &#x60;size&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initUpload(initUploadRequest: InitUploadRequest, options?: RawAxiosRequestConfig): AxiosPromise<UploadInit> {
            return localVarFp.initUpload(initUploadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Checks the processing status of an uploaded file.
         * @summary Check file upload status
         * @param {number} id Upload ID obtained during initialization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusUpload(id: number, options?: RawAxiosRequestConfig): AxiosPromise<UploadStatus> {
            return localVarFp.statusUpload(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UploadApi - object-oriented interface
 */
export class UploadApi extends BaseAPI {
    /**
     * Completes the file upload process after the file has been successfully sent.
     * @summary Complete file upload
     * @param {number} id Upload ID obtained during initialization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public completeUpload(id: number, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).completeUpload(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initializes the file upload process.
     * @summary Initialize file upload
     * @param {InitUploadRequest} initUploadRequest Initializes the file upload process. Requires one of the following parameter combinations: - &#x60;project_id&#x60; and &#x60;url&#x60; - &#x60;project_id&#x60;, &#x60;name&#x60;, and &#x60;size&#x60; 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public initUpload(initUploadRequest: InitUploadRequest, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).initUpload(initUploadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks the processing status of an uploaded file.
     * @summary Check file upload status
     * @param {number} id Upload ID obtained during initialization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public statusUpload(id: number, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).statusUpload(id, options).then((request) => request(this.axios, this.basePath));
    }
}



